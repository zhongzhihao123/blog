<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="vue框架, 钟志豪のblog">
    <meta name="description" content="钟志豪的博客  前端学习  html css js vue jquery  ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>vue框架 | 钟志豪のblog</title>
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/images/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="钟志豪のblog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


    <body>
        <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">钟志豪のblog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">

      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Movies</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Books</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Galleries</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">钟志豪のblog</div>
        <div class="logo-desc">
            
            钟志豪的博客  前端学习  html css js vue jquery  
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-address-book"></i>
			
			友情链接
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>Movies</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Books</span>
                  </a>
                </li>
              
                <li>

                  <a href="/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>Galleries</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }
    
    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }
    /* .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    } */
    /* 导航右上角的图标 */
    
    .github-corner svg {
        color: #F062A7;
        fill: #fff;
        height: 64px;
        width: 64px;
    }
    
    ☞ .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }
    
    .github-corner .octo-arm {
        animation: none;
    }
    
    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

            



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">vue框架</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                <span class="chip bg-color">前端</span>
                            </a>
                        
                            <a href="/tags/vue/">
                                <span class="chip bg-color">vue</span>
                            </a>
                        
                            <a href="/tags/%E6%A1%86%E6%9E%B6/">
                                <span class="chip bg-color">框架</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-07-20
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-07-20
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    79 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Vue-js-Day1"><a href="#Vue-js-Day1" class="headerlink" title="Vue.js - Day1"></a>Vue.js - Day1</h1><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><p>前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp<br>后5天： 以项目驱动教学；</p>
<h3 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h3><ul>
<li>Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</li>
<li>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</li>
<li>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</li>
<li>前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；</li>
</ul>
<h2 id="为什么要学习流行框架"><a href="#为什么要学习流行框架" class="headerlink" title="为什么要学习流行框架"></a>为什么要学习流行框架</h2><ul>
<li>企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；</li>
<li>企业中，使用框架，能够提高开发的效率；</li>
</ul>
<ul>
<li>提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）</li>
<li>在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；</li>
</ul>
<ul>
<li>增强自己就业时候的竞争力</li>
<li>人无我有，人有我优</li>
<li>你平时不忙的时候，都在干嘛？</li>
</ul>
<h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><ul>
<li>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</li>
<li>node 中的 express；</li>
</ul>
<ul>
<li>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</li>
<li><ol>
<li>从Jquery 切换到 Zepto</li>
</ol>
</li>
<li><ol start="2">
<li>从 EJS 切换到 art-template</li>
</ol>
</li>
</ul>
<h2 id="Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别"><a href="#Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别" class="headerlink" title="Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别"></a>Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别</h2><ul>
<li>MVC 是后端的分层开发概念；</li>
<li>MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</li>
<li>为什么有了MVC还要有MVVM</li>
</ul>
<h2 id="Vue-js-基本代码-和-MVVM-之间的对应关系"><a href="#Vue-js-基本代码-和-MVVM-之间的对应关系" class="headerlink" title="Vue.js 基本代码 和 MVVM 之间的对应关系"></a>Vue.js 基本代码 和 MVVM 之间的对应关系</h2><h2 id="Vue之-基本的代码结构和插值表达式、v-cloak"><a href="#Vue之-基本的代码结构和插值表达式、v-cloak" class="headerlink" title="Vue之 - 基本的代码结构和插值表达式、v-cloak"></a>Vue之 - <code>基本的代码结构</code>和<code>插值表达式</code>、<code>v-cloak</code></h2><h2 id="Vue指令之v-text和v-html"><a href="#Vue指令之v-text和v-html" class="headerlink" title="Vue指令之v-text和v-html"></a>Vue指令之<code>v-text</code>和<code>v-html</code></h2><h2 id="Vue指令之v-bind的三种用法"><a href="#Vue指令之v-bind的三种用法" class="headerlink" title="Vue指令之v-bind的三种用法"></a>Vue指令之<code>v-bind</code>的三种用法</h2><ol>
<li>直接使用指令<code>v-bind</code></li>
<li>使用简化指令<code>:</code></li>
<li>在绑定的时候，拼接绑定内容：<code>:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot;</code></li>
</ol>
<h2 id="Vue指令之v-on和跑马灯效果"><a href="#Vue指令之v-on和跑马灯效果" class="headerlink" title="Vue指令之v-on和跑马灯效果"></a>Vue指令之<code>v-on</code>和<code>跑马灯效果</code></h2><h3 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h3><ol>
<li>HTML结构：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;

    &lt;p&gt;{{info}}&lt;/p&gt;

    &lt;input type=&quot;button&quot; value=&quot;开启&quot; v-on:click=&quot;go&quot;&gt;

    &lt;input type=&quot;button&quot; value=&quot;停止&quot; v-on:click=&quot;stop&quot;&gt;

  &lt;/div&gt;
</code></pre><ol start="2">
<li>Vue实例：</li>
</ol>
<pre><code>    // 创建 Vue 实例，得到 ViewModel

    var vm = new Vue({

      el: &#39;#app&#39;,

      data: {

        info: &#39;猥琐发育，别浪~！&#39;,

        intervalId: null

      },

      methods: {

        go() {

          // 如果当前有定时器在运行，则直接return

          if (this.intervalId != null) {

            return;

          }

          // 开始定时器

          this.intervalId = setInterval(() =&gt; {

            this.info = this.info.substring(1) + this.info.substring(0, 1);

          }, 500);

        },

        stop() {

          clearInterval(this.intervalId);

        }

      }

    });
</code></pre><h2 id="Vue指令之v-on的缩写和事件修饰符"><a href="#Vue指令之v-on的缩写和事件修饰符" class="headerlink" title="Vue指令之v-on的缩写和事件修饰符"></a>Vue指令之<code>v-on的缩写</code>和<code>事件修饰符</code></h2><h3 id="事件修饰符："><a href="#事件修饰符：" class="headerlink" title="事件修饰符："></a>事件修饰符：</h3><ul>
<li>.stop       阻止冒泡</li>
<li>.prevent    阻止默认事件</li>
<li>.capture    添加事件侦听器时使用事件捕获模式</li>
<li>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</li>
<li>.once       事件只触发一次</li>
</ul>
<h2 id="Vue指令之v-model和双向数据绑定"><a href="#Vue指令之v-model和双向数据绑定" class="headerlink" title="Vue指令之v-model和双向数据绑定"></a>Vue指令之<code>v-model</code>和<code>双向数据绑定</code></h2><h2 id="简易计算器案例"><a href="#简易计算器案例" class="headerlink" title="简易计算器案例"></a>简易计算器案例</h2><ol>
<li>HTML 代码结构</li>
</ol>
<pre><code>  &lt;div id=&quot;app&quot;&gt;

    &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt;

    &lt;select v-model=&quot;opt&quot;&gt;

      &lt;option value=&quot;0&quot;&gt;+&lt;/option&gt;

      &lt;option value=&quot;1&quot;&gt;-&lt;/option&gt;

      &lt;option value=&quot;2&quot;&gt;*&lt;/option&gt;

      &lt;option value=&quot;3&quot;&gt;÷&lt;/option&gt;

    &lt;/select&gt;

    &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt;

    &lt;input type=&quot;button&quot; value=&quot;=&quot; v-on:click=&quot;getResult&quot;&gt;

    &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt;

  &lt;/div&gt;
</code></pre><ol start="2">
<li>Vue实例代码：</li>
</ol>
<pre><code>    // 创建 Vue 实例，得到 ViewModel

    var vm = new Vue({

      el: &#39;#app&#39;,

      data: {

        n1: 0,

        n2: 0,

        result: 0,

        opt: &#39;0&#39;

      },

      methods: {

        getResult() {

          switch (this.opt) {

            case &#39;0&#39;:

              this.result = parseInt(this.n1) + parseInt(this.n2);

              break;

            case &#39;1&#39;:

              this.result = parseInt(this.n1) - parseInt(this.n2);

              break;

            case &#39;2&#39;:

              this.result = parseInt(this.n1) * parseInt(this.n2);

              break;

            case &#39;3&#39;:

              this.result = parseInt(this.n1) / parseInt(this.n2);

              break;

          }

        }

      }

    });
</code></pre><h2 id="在Vue中使用样式"><a href="#在Vue中使用样式" class="headerlink" title="在Vue中使用样式"></a>在Vue中使用样式</h2><h3 id="使用class样式"><a href="#使用class样式" class="headerlink" title="使用class样式"></a>使用class样式</h3><ol>
<li>数组</li>
</ol>
<pre><code>&lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre><ol start="2">
<li>数组中使用三元表达式</li>
</ol>
<pre><code>&lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre><ol start="3">
<li>数组中嵌套对象</li>
</ol>
<pre><code>&lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;, {&#39;active&#39;: isactive}]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre><ol start="4">
<li>直接使用对象</li>
</ol>
<pre><code>&lt;h1 :class=&quot;{red:true, italic:true, active:true, thin:true}&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre><h3 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h3><ol>
<li>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</li>
</ol>
<pre><code>&lt;h1 :style=&quot;{color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;}&quot;&gt;这是一个善良的H1&lt;/h1&gt;

</code></pre><ol start="2">
<li>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</li>
</ol>
<ul>
<li>在data上定义样式：</li>
</ul>
<pre><code>data: {
        h1StyleObj: { color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; }
}

</code></pre><ul>
<li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</li>
</ul>
<pre><code>&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt;

</code></pre><ol start="3">
<li>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</li>
</ol>
<ul>
<li>在data上定义样式：</li>
</ul>
<pre><code>data: {
        h1StyleObj: { color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; },
        h1StyleObj2: { fontStyle: &#39;italic&#39; }
}

</code></pre><ul>
<li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：</li>
</ul>
<pre><code>&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt;

</code></pre><h2 id="Vue指令之v-for和key属性"><a href="#Vue指令之v-for和key属性" class="headerlink" title="Vue指令之v-for和key属性"></a>Vue指令之<code>v-for</code>和<code>key</code>属性</h2><ol>
<li>迭代数组</li>
</ol>
<pre><code>&lt;ul&gt;
  &lt;li v-for=&quot;(item, i) in list&quot;&gt;索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}&lt;/li&gt;
&lt;/ul&gt;

</code></pre><ol start="2">
<li>迭代对象中的属性</li>
</ol>
<pre><code>    &lt;!-- 循环遍历对象身上的属性 --&gt;

    &lt;div v-for=&quot;(val, key, i) in userInfo&quot;&gt;{{val}} --- {{key}} --- {{i}}&lt;/div&gt;


</code></pre><ol start="3">
<li>迭代数字</li>
</ol>
<pre><code>&lt;p v-for=&quot;i in 10&quot;&gt;这是第 {{i}} 个P标签&lt;/p&gt;


</code></pre><blockquote>
<p>2.2.0+ 的版本里，<strong>当在组件中使用</strong> v-for 时，key 现在是必须的。</p>
</blockquote>
<p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p>
<p>为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p>
<h2 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h2><blockquote>
<p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p>
</blockquote>
<h2 id="品牌管理案例"><a href="#品牌管理案例" class="headerlink" title="品牌管理案例"></a>品牌管理案例</h2><h3 id="添加新品牌"><a href="#添加新品牌" class="headerlink" title="添加新品牌"></a>添加新品牌</h3><h3 id="删除品牌"><a href="#删除品牌" class="headerlink" title="删除品牌"></a>删除品牌</h3><h3 id="根据条件筛选品牌"><a href="#根据条件筛选品牌" class="headerlink" title="根据条件筛选品牌"></a>根据条件筛选品牌</h3><ol>
<li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li>
</ol>
<p><a href="https://v1-cn.vuejs.org/api/#filterBy" target="_blank" rel="noopener">filterBy - 指令</a></p>
<pre><code>&lt;tr v-for=&quot;item in list | filterBy searchName in &#39;name&#39;&quot;&gt;

  &lt;td&gt;{{item.id}}&lt;/td&gt;

  &lt;td&gt;{{item.name}}&lt;/td&gt;

  &lt;td&gt;{{item.ctime}}&lt;/td&gt;

  &lt;td&gt;

    &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;

  &lt;/td&gt;

&lt;/tr&gt;


</code></pre><ol start="2">
<li>在2.x版本中<a href="https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果" target="_blank" rel="noopener">手动实现筛选的方式</a>：</li>
</ol>
<ul>
<li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li>
</ul>
<pre><code>&lt;hr&gt; 输入筛选名称：

&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt;


</code></pre><ul>
<li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li>
</ul>
<pre><code>&lt;tbody&gt;

      &lt;tr v-for=&quot;item in search(searchName)&quot;&gt;

        &lt;td&gt;{{item.id}}&lt;/td&gt;

        &lt;td&gt;{{item.name}}&lt;/td&gt;

        &lt;td&gt;{{item.ctime}}&lt;/td&gt;

        &lt;td&gt;

          &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;

        &lt;/td&gt;

      &lt;/tr&gt;

    &lt;/tbody&gt;


</code></pre><ul>
<li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li>
</ul>
<pre><code>search(name) {

  return this.list.filter(x =&gt; {

    return x.name.indexOf(name) != -1;

  });

}


</code></pre><h2 id="Vue调试工具vue-devtools的安装步骤和使用"><a href="#Vue调试工具vue-devtools的安装步骤和使用" class="headerlink" title="Vue调试工具vue-devtools的安装步骤和使用"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h2><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p>
<h3 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h3><ol>
<li>HTML元素：</li>
</ol>
<pre><code>&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt;


</code></pre><ol start="2">
<li>私有 <code>filters</code> 定义方式：</li>
</ol>
<pre><code>filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用

    dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错

      var dt = new Date(input);

      // 获取年月日

      var y = dt.getFullYear();

      var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);

      var d = dt.getDate().toString().padStart(2, &#39;0&#39;);



      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

      // 否则，就返回  年-月-日 时：分：秒

      if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) {

        return `${y}-${m}-${d}`;

      } else {

        // 获取时分秒

        var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);

        var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);

        var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);



        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;

      }

    }

  }


</code></pre><blockquote>
<p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p>
</blockquote>
<h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><pre><code>// 定义一个全局过滤器

Vue.filter(&#39;dataFormat&#39;, function (input, pattern = &#39;&#39;) {

  var dt = new Date(input);

  // 获取年月日

  var y = dt.getFullYear();

  var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);

  var d = dt.getDate().toString().padStart(2, &#39;0&#39;);



  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

  // 否则，就返回  年-月-日 时：分：秒

  if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) {

    return `${y}-${m}-${d}`;

  } else {

    // 获取时分秒

    var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);

    var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);

    var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);



    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;

  }

});


</code></pre><blockquote>
<p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p>
</blockquote>
<h2 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id="1-x中自定义键盘修饰符【了解即可】"><a href="#1-x中自定义键盘修饰符【了解即可】" class="headerlink" title="1.x中自定义键盘修饰符【了解即可】"></a>1.x中自定义键盘修饰符【了解即可】</h3><pre><code>Vue.directive(&#39;on&#39;).keyCodes.f2 = 113;


</code></pre><h3 id="2-x中自定义键盘修饰符"><a href="#2-x中自定义键盘修饰符" class="headerlink" title="2.x中自定义键盘修饰符"></a><a href="https://cn.vuejs.org/v2/guide/events.html#键值修饰符" target="_blank" rel="noopener">2.x中自定义键盘修饰符</a></h3><ol>
<li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li>
</ol>
<pre><code>Vue.config.keyCodes.f2 = 113;

</code></pre><ol start="2">
<li>使用自定义的按键修饰符：</li>
</ol>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;

</code></pre><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></h2><ol>
<li>自定义全局和局部的 自定义指令：</li>
</ol>
<pre><code>    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：

    Vue.directive(&#39;focus&#39;, {

      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用

        el.focus();

      }

    });



    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：

      directives: {

        color: { // 为元素设置指定的字体颜色

          bind(el, binding) {

            el.style.color = binding.value;

          }

        },

        &#39;font-weight&#39;: function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数

          el.style.fontWeight = binding2.value;

        }

      }

</code></pre><ol start="2">
<li>自定义指令的使用方式：</li>
</ol>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&#39;red&#39;&quot; v-font-weight=&quot;900&quot;&gt;

</code></pre><h2 id="Vue-1-x-中-自定义元素指令【已废弃-了解即可】"><a href="#Vue-1-x-中-自定义元素指令【已废弃-了解即可】" class="headerlink" title="Vue 1.x 中 自定义元素指令【已废弃,了解即可】"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h2><pre><code>Vue.elementDirective(&#39;red-color&#39;, {
  bind: function () {
    this.el.style.color = &#39;red&#39;;
  }
});
</code></pre><p>使用方式：</p>
<pre><code>&lt;red-color&gt;1232&lt;/red-color&gt;
</code></pre><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol>
<li><a href="https://v1-cn.vuejs.org/" target="_blank" rel="noopener">vue.js 1.x 文档</a></li>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js 2.x 文档</a></li>
<li><a href="http://www.css88.com/archives/7715" target="_blank" rel="noopener">String.prototype.padStart(maxLength, fillString)</a></li>
<li><a href="http://www.cnblogs.com/wuhua1/p/6686237.html" target="_blank" rel="noopener">js 里面的键盘事件对应的键码</a></li>
<li><a href="http://www.cnblogs.com/kidney/p/6052935.html" target="_blank" rel="noopener">Vue.js双向绑定的实现原理</a></li>
</ol>
<h2 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h2><p>用于快速生成vue项目基础架构     <a href="http://cli.vuejs.org/zh/" target="_blank" rel="noopener">地址</a></p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1 安装3.x版本的Vue脚手架：</p>
<p><code>npm install -g @vue/cli</code></p>
<h3 id="vue脚手架的基本用法"><a href="#vue脚手架的基本用法" class="headerlink" title="vue脚手架的基本用法"></a>vue脚手架的基本用法</h3><p>基于3.x版本的脚手架创建vue项目</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//1.基于交互式命令行的方式，创建新版vue项目</span>
vue create my<span class="token operator">-</span>project
<span class="token comment" spellcheck="true">//2.基于图形化界面的方式，创建新版vue项目</span>
vue ui
<span class="token comment" spellcheck="true">//3.基于2.x的旧模板，创建旧版vue项目</span>
npm install <span class="token operator">-</span>g @vue<span class="token operator">/</span>cli<span class="token operator">-</span>init
vue init webpack my<span class="token operator">-</span>project
</code></pre>
<p>B.基于3.x版本的脚手架创建Vue项目：<br>    1).使用命令创建Vue项目<br>        命令：vue create my-project<br>        选择Manually select features(选择特性以创建项目)<br>        勾选特性可以用空格进行勾选。<br>        是否选用历史模式的路由：n<br>        ESLint选择：ESLint + Standard config<br>        何时进行ESLint语法校验：Lint on save<br>        babel，postcss等配置文件如何放置：In dedicated config files(单独使用文件进行配置)<br>        是否保存为模板：n<br>        使用哪个工具安装包：npm<br>    2).基于ui界面创建Vue项目<br>        命令：vue ui<br>        在自动打开的创建项目网页中配置项目信息。<br>    3).基于2.x的旧模板，创建Vue项目<br>        npm install -g @vue/cli-init<br>        vue init webpack my-project</p>
<p>C.分析Vue脚手架生成的项目结构<br>    node_modules:依赖包目录<br>    public：静态资源目录<br>    src：源码目录<br>    src/assets:资源目录<br>    src/components：组件目录<br>    src/views:视图组件目录<br>    src/App.vue:根组件<br>    src/main.js:入口js<br>    src/router.js:路由js<br>    babel.config.js:babel配置文件<br>    .eslintrc.js:</p>
<p>###16.Vue脚手架的自定义配置<br>    A.通过 package.json 进行配置 [不推荐使用]<br>        “vue”:{<br>            “devServer”:{<br>                “port”:”9990”,<br>                “open”:true<br>            }<br>        }<br>    B.通过单独的配置文件进行配置，创建vue.config.js<br>        module.exports = {<br>            devServer:{<br>                port:8888,<br>                open:true<br>            }<br>        }</p>
<h2 id="Element-UI的基本使用"><a href="#Element-UI的基本使用" class="headerlink" title="Element-UI的基本使用"></a>Element-UI的基本使用</h2><p>Element-UI:一套基于2.0的桌面端组件库<br>官网地址：<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a></p>
<p>A.安装：<br>    npm install element-ui -S<br>B.导入使用：<br>    import ElementUI from “element-ui”;<br>    import “element-ui/lib/theme-chalk/index.css”;</p>
<pre class=" language-javascript"><code class="language-javascript"> Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>ElementUI<span class="token punctuation">)</span>
</code></pre>
<h3 id="基于图形化界面自动安装"><a href="#基于图形化界面自动安装" class="headerlink" title="基于图形化界面自动安装"></a>基于图形化界面自动安装</h3><ol>
<li>运行vue ui命令，打开图形化界面</li>
<li>通过vue项目管理器，进入具体的项目配置面板</li>
<li>点击插件-&gt;添加插件，进入插件查询面板</li>
<li>搜索vue-cli-plugin-element并安装</li>
<li>配置插件，实现按需导入，从而减少打包后项目的体积</li>
</ol>
<h1 id="Vue-js-Day2"><a href="#Vue-js-Day2" class="headerlink" title="Vue.js - Day2"></a>Vue.js - Day2</h1><h2 id="品牌管理案例-1"><a href="#品牌管理案例-1" class="headerlink" title="品牌管理案例"></a>品牌管理案例</h2><h3 id="添加新品牌-1"><a href="#添加新品牌-1" class="headerlink" title="添加新品牌"></a>添加新品牌</h3><h3 id="删除品牌-1"><a href="#删除品牌-1" class="headerlink" title="删除品牌"></a>删除品牌</h3><h3 id="根据条件筛选品牌-1"><a href="#根据条件筛选品牌-1" class="headerlink" title="根据条件筛选品牌"></a>根据条件筛选品牌</h3><ol>
<li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li>
</ol>
<p><a href="https://v1-cn.vuejs.org/api/#filterBy" target="_blank" rel="noopener">filterBy - 指令</a></p>
<pre><code>&lt;tr v-for=&quot;item in list | filterBy searchName in &#39;name&#39;&quot;&gt;

  &lt;td&gt;{{item.id}}&lt;/td&gt;

  &lt;td&gt;{{item.name}}&lt;/td&gt;

  &lt;td&gt;{{item.ctime}}&lt;/td&gt;

  &lt;td&gt;

    &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;

  &lt;/td&gt;

&lt;/tr&gt;

</code></pre><ol start="2">
<li>在2.x版本中<a href="https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果" target="_blank" rel="noopener">手动实现筛选的方式</a>：</li>
</ol>
<ul>
<li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li>
</ul>
<pre><code>&lt;hr&gt; 输入筛选名称：

&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt;

</code></pre><ul>
<li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li>
</ul>
<pre><code>&lt;tbody&gt;

      &lt;tr v-for=&quot;item in search(searchName)&quot;&gt;

        &lt;td&gt;{{item.id}}&lt;/td&gt;

        &lt;td&gt;{{item.name}}&lt;/td&gt;

        &lt;td&gt;{{item.ctime}}&lt;/td&gt;

        &lt;td&gt;

          &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;

        &lt;/td&gt;

      &lt;/tr&gt;

    &lt;/tbody&gt;

</code></pre><ul>
<li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li>
</ul>
<pre><code>search(name) {

  return this.list.filter(x =&gt; {

    return x.name.indexOf(name) != -1;

  });

}

</code></pre><h2 id="Vue调试工具vue-devtools的安装步骤和使用-1"><a href="#Vue调试工具vue-devtools的安装步骤和使用-1" class="headerlink" title="Vue调试工具vue-devtools的安装步骤和使用"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h2><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p>
<h2 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p>
<h3 id="私有过滤器-1"><a href="#私有过滤器-1" class="headerlink" title="私有过滤器"></a>私有过滤器</h3><ol>
<li>HTML元素：</li>
</ol>
<pre><code>&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt;

</code></pre><ol start="2">
<li>私有 <code>filters</code> 定义方式：</li>
</ol>
<pre><code>filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用

    dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错

      var dt = new Date(input);

      // 获取年月日

      var y = dt.getFullYear();

      var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);

      var d = dt.getDate().toString().padStart(2, &#39;0&#39;);



      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

      // 否则，就返回  年-月-日 时：分：秒

      if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) {

        return `${y}-${m}-${d}`;

      } else {

        // 获取时分秒

        var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);

        var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);

        var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);



        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;

      }

    }

  }

</code></pre><blockquote>
<p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p>
</blockquote>
<h3 id="全局过滤器-1"><a href="#全局过滤器-1" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><pre><code>// 定义一个全局过滤器

Vue.filter(&#39;dataFormat&#39;, function (input, pattern = &#39;&#39;) {

  var dt = new Date(input);

  // 获取年月日

  var y = dt.getFullYear();

  var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);

  var d = dt.getDate().toString().padStart(2, &#39;0&#39;);



  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

  // 否则，就返回  年-月-日 时：分：秒

  if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) {

    return `${y}-${m}-${d}`;

  } else {

    // 获取时分秒

    var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);

    var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);

    var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);



    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;

  }

});

</code></pre><blockquote>
<p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p>
</blockquote>
<h2 id="键盘修饰符以及自定义键盘修饰符-1"><a href="#键盘修饰符以及自定义键盘修饰符-1" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id="1-x中自定义键盘修饰符【了解即可】-1"><a href="#1-x中自定义键盘修饰符【了解即可】-1" class="headerlink" title="1.x中自定义键盘修饰符【了解即可】"></a>1.x中自定义键盘修饰符【了解即可】</h3><pre><code>Vue.directive(&#39;on&#39;).keyCodes.f2 = 113;

</code></pre><h3 id="2-x中自定义键盘修饰符-1"><a href="#2-x中自定义键盘修饰符-1" class="headerlink" title="2.x中自定义键盘修饰符"></a><a href="https://cn.vuejs.org/v2/guide/events.html#键值修饰符" target="_blank" rel="noopener">2.x中自定义键盘修饰符</a></h3><ol>
<li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li>
</ol>
<pre><code>Vue.config.keyCodes.f2 = 113;


</code></pre><ol start="2">
<li>使用自定义的按键修饰符：</li>
</ol>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;


</code></pre><h2 id="自定义指令-1"><a href="#自定义指令-1" class="headerlink" title="自定义指令"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></h2><ol>
<li>自定义全局和局部的 自定义指令：</li>
</ol>
<pre><code>    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：

    Vue.directive(&#39;focus&#39;, {

      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用

        el.focus();

      }

    });



    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：

      directives: {

        color: { // 为元素设置指定的字体颜色

          bind(el, binding) {

            el.style.color = binding.value;

          }

        },

        &#39;font-weight&#39;: function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数

          el.style.fontWeight = binding2.value;

        }

      }


</code></pre><ol start="2">
<li>自定义指令的使用方式：</li>
</ol>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&#39;red&#39;&quot; v-font-weight=&quot;900&quot;&gt;


</code></pre><h2 id="Vue-1-x-中-自定义元素指令【已废弃-了解即可】-1"><a href="#Vue-1-x-中-自定义元素指令【已废弃-了解即可】-1" class="headerlink" title="Vue 1.x 中 自定义元素指令【已废弃,了解即可】"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h2><pre><code>Vue.elementDirective(&#39;red-color&#39;, {
  bind: function () {
    this.el.style.color = &#39;red&#39;;
  }
});

</code></pre><p>使用方式：</p>
<pre><code>&lt;red-color&gt;1232&lt;/red-color&gt;

</code></pre><h2 id="vue实例的生命周期"><a href="#vue实例的生命周期" class="headerlink" title="vue实例的生命周期"></a><a href="https://cn.vuejs.org/v2/guide/instance.html#实例生命周期" target="_blank" rel="noopener">vue实例的生命周期</a></h2><ul>
<li>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</li>
<li><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</li>
<li>生命周期钩子 = 生命周期函数 = 生命周期事件</li>
<li>主要的生命周期函数分类：</li>
<li>创建期间的生命周期函数：</li>
<li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li>
<li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li>
<li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li>
<li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
<li>运行期间的生命周期函数：</li>
<li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
<li>销毁期间的生命周期函数：</li>
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<h2 id="vue-resource-实现-get-post-jsonp请求"><a href="#vue-resource-实现-get-post-jsonp请求" class="headerlink" title="vue-resource 实现 get, post, jsonp请求"></a><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">vue-resource 实现 get, post, jsonp请求</a></h2><p>除了 vue-resource 之外，还可以使用 <code>axios</code> 的第三方包实现实现数据的请求</p>
<ol>
<li>之前的学习中，如何发起数据请求？</li>
<li>常见的数据请求类型？  get  post jsonp</li>
<li>测试的URL请求资源地址：</li>
</ol>
<ul>
<li>get请求地址： <a href="http://vue.studyit.io/api/getlunbo" target="_blank" rel="noopener">http://vue.studyit.io/api/getlunbo</a></li>
<li>post请求地址：<a href="http://vue.studyit.io/api/post" target="_blank" rel="noopener">http://vue.studyit.io/api/post</a></li>
<li>jsonp请求地址：<a href="http://vue.studyit.io/api/jsonp" target="_blank" rel="noopener">http://vue.studyit.io/api/jsonp</a></li>
</ul>
<ol start="4">
<li>JSONP的实现原理</li>
</ol>
<ul>
<li>由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；</li>
<li>可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；</li>
<li>具体实现过程：</li>
<li>先在客户端定义一个回调方法，预定义对数据的操作；</li>
<li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；</li>
<li>服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；</li>
<li>客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；</li>
<li>带大家通过 Node.js ，来手动实现一个JSONP的请求例子；</li>
</ul>
<pre><code>    const http = require(&#39;http&#39;);
    // 导入解析 URL 地址的核心模块
    const urlModule = require(&#39;url&#39;);

    const server = http.createServer();
    // 监听 服务器的 request 请求事件，处理每个请求
    server.on(&#39;request&#39;, (req, res) =&gt; {
      const url = req.url;

      // 解析客户端请求的URL地址
      var info = urlModule.parse(url, true);

      // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据
      if (info.pathname === &#39;/getjsonp&#39;) {
        // 获取客户端指定的回调函数的名称
        var cbName = info.query.callback;
        // 手动拼接要返回给客户端的数据对象
        var data = {
          name: &#39;zs&#39;,
          age: 22,
          gender: &#39;男&#39;,
          hobby: [&#39;吃饭&#39;, &#39;睡觉&#39;, &#39;运动&#39;]
        }
        // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：
        var result = `${cbName}(${JSON.stringify(data)})`;
        // 将拼接好的方法的调用，返回给客户端去解析执行
        res.end(result);
      } else {
        res.end(&#39;404&#39;);
      }
    });

    server.listen(3000, () =&gt; {
      console.log(&#39;server running at http://127.0.0.1:3000&#39;);
    });

</code></pre><ol start="5">
<li>vue-resource 的配置步骤：</li>
</ol>
<ul>
<li>直接在页面中，通过<code>script</code>标签，引入 <code>vue-resource</code> 的脚本文件；</li>
<li>注意：引用的先后顺序是：先引用 <code>Vue</code> 的脚本文件，再引用 <code>vue-resource</code> 的脚本文件；</li>
</ul>
<ol start="6">
<li>发送get请求：</li>
</ol>
<pre><code>getInfo() { // get 方式获取数据
  this.$http.get(&#39;http://127.0.0.1:8899/api/getlunbo&#39;).then(res =&gt; {
    console.log(res.body);
  })
}

</code></pre><ol start="7">
<li>发送post请求：</li>
</ol>
<pre><code>postInfo() {
  var url = &#39;http://127.0.0.1:8899/api/post&#39;;
  // post 方法接收三个参数：
  // 参数1： 要请求的URL地址
  // 参数2： 要发送的数据对象
  // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded
  this.$http.post(url, { name: &#39;zs&#39; }, { emulateJSON: true }).then(res =&gt; {
    console.log(res.body);
  });
}

</code></pre><ol start="8">
<li>发送JSONP请求获取数据：</li>
</ol>
<pre><code>jsonpInfo() { // JSONP形式从服务器获取数据
  var url = &#39;http://127.0.0.1:8899/api/jsonp&#39;;
  this.$http.jsonp(url).then(res =&gt; {
    console.log(res.body);
  });
}

</code></pre><h2 id="配置本地数据库和数据接口API"><a href="#配置本地数据库和数据接口API" class="headerlink" title="配置本地数据库和数据接口API"></a>配置本地数据库和数据接口API</h2><ol>
<li>先解压安装 <code>PHPStudy</code>;</li>
<li>解压安装 <code>Navicat</code> 这个数据库可视化工具，并激活；</li>
<li>打开 <code>Navicat</code> 工具，新建空白数据库，名为 <code>dtcmsdb4</code>;</li>
<li>双击新建的数据库，连接上这个空白数据库，在新建的数据库上<code>右键</code> -&gt; <code>运行SQL文件</code>，选择并执行 <code>dtcmsdb4.sql</code> 这个数据库脚本文件；如果执行不报错，则数据库导入完成；</li>
<li>进入文件夹 <code>vuecms3_nodejsapi</code> 内部，执行 <code>npm i</code> 安装所有的依赖项；</li>
<li>先确保本机安装了 <code>nodemon</code>, 没有安装，则运行 <code>npm i nodemon -g</code> 进行全局安装，安装完毕后，进入到 <code>vuecms3_nodejsapi</code>目录 -&gt; <code>src</code>目录 -&gt; 双击运行 <code>start.bat</code></li>
<li>如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 <code>app.js</code> 中第 <code>14行</code> 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root</li>
</ol>
<h2 id="品牌管理改造"><a href="#品牌管理改造" class="headerlink" title="品牌管理改造"></a>品牌管理改造</h2><h3 id="展示品牌列表"><a href="#展示品牌列表" class="headerlink" title="展示品牌列表"></a>展示品牌列表</h3><h3 id="添加品牌数据"><a href="#添加品牌数据" class="headerlink" title="添加品牌数据"></a>添加品牌数据</h3><h3 id="删除品牌数据"><a href="#删除品牌数据" class="headerlink" title="删除品牌数据"></a>删除品牌数据</h3><h2 id="Vue中的动画"><a href="#Vue中的动画" class="headerlink" title="Vue中的动画"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Vue中的动画</a></h2><p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p>
<h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><ol>
<li>HTML结构：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt;
    &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;
    &lt;transition name=&quot;fade&quot;&gt;
      &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;
    &lt;/transition&gt;
  &lt;/div&gt;

</code></pre><ol start="2">
<li>VM 实例：</li>
</ol>
<pre><code>// 创建 Vue 实例，得到 ViewModel
var vm = new Vue({
  el: &#39;#app&#39;,
  data: {
    isshow: false
  },
  methods: {
    myAnimate() {
      this.isshow = !this.isshow;
    }
  }
});

</code></pre><ol start="3">
<li>定义两组类样式：</li>
</ol>
<pre><code>/* 定义进入和离开时候的过渡状态 */
    .fade-enter-active,
    .fade-leave-active {
      transition: all 0.2s ease;
      position: absolute;
    }

    /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */
    .fade-enter,
    .fade-leave-to {
      opacity: 0;
      transform: translateX(100px);
    }

</code></pre><h3 id="使用第三方-CSS-动画库"><a href="#使用第三方-CSS-动画库" class="headerlink" title="使用第三方 CSS 动画库"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名" target="_blank" rel="noopener">使用第三方 CSS 动画库</a></h3><ol>
<li>导入动画类库：</li>
</ol>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt;

</code></pre><ol start="2">
<li>定义 transition 及属性：</li>
</ol>
<pre><code>&lt;transition
    enter-active-class=&quot;fadeInRight&quot;
    leave-active-class=&quot;fadeOutRight&quot;
    :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt;
      &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;
&lt;/transition&gt;

</code></pre><h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><ol>
<li>定义 transition 组件以及三个钩子函数：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt;
    &lt;transition
    @before-enter=&quot;beforeEnter&quot;
    @enter=&quot;enter&quot;
    @after-enter=&quot;afterEnter&quot;&gt;
      &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt;
    &lt;/transition&gt;
  &lt;/div&gt;

</code></pre><ol start="2">
<li>定义三个 methods 钩子方法：</li>
</ol>
<pre><code>methods: {
        beforeEnter(el) { // 动画进入之前的回调
          el.style.transform = &#39;translateX(500px)&#39;;
        },
        enter(el, done) { // 动画进入完成时候的回调
          el.offsetWidth;
          el.style.transform = &#39;translateX(0px)&#39;;
          done();
        },
        afterEnter(el) { // 动画进入完成之后的回调
          this.isshow = !this.isshow;
        }
      }

</code></pre><ol start="3">
<li>定义动画过渡时长和样式：</li>
</ol>
<pre><code>.show{
      transition: all 0.4s ease;
    }

</code></pre><h3 id="v-for-的列表过渡"><a href="#v-for-的列表过渡" class="headerlink" title="v-for 的列表过渡"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡" target="_blank" rel="noopener">v-for 的列表过渡</a></h3><ol>
<li>定义过渡样式：</li>
</ol>
<pre><code>&lt;style&gt;
    .list-enter,
    .list-leave-to {
      opacity: 0;
      transform: translateY(10px);
    }

    .list-enter-active,
    .list-leave-active {
      transition: all 0.3s ease;
    }
&lt;/style&gt;

</code></pre><ol start="2">
<li>定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：</li>
</ol>
<pre><code>  &lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt;

    &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt;
      &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;{{item}}&lt;/li&gt;
    &lt;/transition-group&gt;
  &lt;/div&gt;

</code></pre><ol start="3">
<li>定义 VM中的结构：</li>
</ol>
<pre><code>    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        txt: &#39;&#39;,
        list: [1, 2, 3, 4]
      },
      methods: {
        add() {
          this.list.push(this.txt);
          this.txt = &#39;&#39;;
        }
      }
    });

</code></pre><h3 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p>
<ul>
<li><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：</li>
</ul>
<pre><code>.v-move{
  transition: all 0.8s ease;
}
.v-leave-active{
  position: absolute;
}
</code></pre><h2 id="相关文章-1"><a href="#相关文章-1" class="headerlink" title="相关文章"></a>相关文章</h2><ol>
<li><a href="https://v1-cn.vuejs.org/" target="_blank" rel="noopener">vue.js 1.x 文档</a></li>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js 2.x 文档</a></li>
<li><a href="http://www.css88.com/archives/7715" target="_blank" rel="noopener">String.prototype.padStart(maxLength, fillString)</a></li>
<li><a href="http://www.cnblogs.com/wuhua1/p/6686237.html" target="_blank" rel="noopener">js 里面的键盘事件对应的键码</a></li>
<li><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">pagekit/vue-resource</a></li>
<li><a href="https://jingyan.baidu.com/article/a65957f4976aad24e67f9b9b.html" target="_blank" rel="noopener">navicat如何导入sql文件和导出sql文件</a></li>
<li><a href="http://cubic-bezier.com/#.4,-0.3,1,.33" target="_blank" rel="noopener">贝塞尔在线生成器</a></li>
</ol>
<h1 id="Vue-js-Day3"><a href="#Vue-js-Day3" class="headerlink" title="Vue.js - Day3"></a>Vue.js - Day3</h1><h2 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h2><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p>
<ul>
<li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li>
<li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；</li>
</ul>
<h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><ol>
<li>使用 Vue.extend 配合 Vue.component 方法：</li>
</ol>
<pre><code>var login = Vue.extend({
      template: &#39;&lt;h1&gt;登录&lt;/h1&gt;&#39;
    });
    Vue.component(&#39;login&#39;, login);
</code></pre><ol start="2">
<li>直接使用 Vue.component 方法：</li>
</ol>
<pre><code>Vue.component(&#39;register&#39;, {
      template: &#39;&lt;h1&gt;注册&lt;/h1&gt;&#39;
    });
</code></pre><ol start="3">
<li>将模板字符串，定义到script标签种：</li>
</ol>
<pre><code>&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;
      &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;
    &lt;/script&gt;
</code></pre><p>同时，需要使用 Vue.component 来定义组件：</p>
<pre><code>Vue.component(&#39;account&#39;, {
      template: &#39;#tmpl&#39;
    });
</code></pre><blockquote>
<p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p>
</blockquote>
<h3 id="组件中展示数据和响应事件"><a href="#组件中展示数据和响应事件" class="headerlink" title="组件中展示数据和响应事件"></a>组件中展示数据和响应事件</h3><ol>
<li>在组件中，<code>data</code>需要被定义为一个方法，例如：</li>
</ol>
<pre><code>Vue.component(&#39;account&#39;, {
      template: &#39;#tmpl&#39;,
      data() {
        return {
          msg: &#39;大家好！&#39;
        }
      },
      methods:{
        login(){
          alert(&#39;点击了登录按钮&#39;);
        }
      }
    });
</code></pre><ol start="2">
<li>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</li>
</ol>
<h3 id="【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象"><a href="#【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象" class="headerlink" title="【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象"></a>【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象</h3><ol>
<li>通过计数器案例演示</li>
</ol>
<h3 id="使用components属性定义局部子组件"><a href="#使用components属性定义局部子组件" class="headerlink" title="使用components属性定义局部子组件"></a>使用<code>components</code>属性定义局部子组件</h3><ol>
<li>组件实例定义方式：</li>
</ol>
<pre><code>&lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {},
      components: { // 定义子组件
        account: { // account 组件
          template: &#39;&lt;div&gt;&lt;h1&gt;这是Account组件{{name}}&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;&#39;, // 在这里使用定义的子组件
          components: { // 定义子组件的子组件
            login: { // login 组件
              template: &quot;&lt;h3&gt;这是登录组件&lt;/h3&gt;&quot;
            }
          }
        }
      }
    });
  &lt;/script&gt;
</code></pre><ol start="2">
<li>引用组件：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;account&gt;&lt;/account&gt;
  &lt;/div&gt;
</code></pre><h2 id="使用flag标识符结合v-if和v-else切换组件"><a href="#使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="使用flag标识符结合v-if和v-else切换组件"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h2><ol>
<li>页面结构：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt;
    &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt;
    &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt;
  &lt;/div&gt;
</code></pre><ol start="2">
<li>Vue实例定义：</li>
</ol>
<pre><code>&lt;script&gt;
    Vue.component(&#39;myCom1&#39;, {
      template: &#39;&lt;h3&gt;奔波霸&lt;/h3&gt;&#39;
    })

    Vue.component(&#39;myCom2&#39;, {
      template: &#39;&lt;h3&gt;霸波奔&lt;/h3&gt;&#39;
    })

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        flag: true
      },
      methods: {}
    });
  &lt;/script&gt;

</code></pre><h2 id="使用-is属性来切换不同的子组件-并添加切换动画"><a href="#使用-is属性来切换不同的子组件-并添加切换动画" class="headerlink" title="使用:is属性来切换不同的子组件,并添加切换动画"></a>使用<code>:is</code>属性来切换不同的子组件,并添加切换动画</h2><ol>
<li>组件实例定义方式：</li>
</ol>
<pre><code>  // 登录组件
    const login = Vue.extend({
      template: `&lt;div&gt;
        &lt;h3&gt;登录组件&lt;/h3&gt;
      &lt;/div&gt;`
    });
    Vue.component(&#39;login&#39;, login);

    // 注册组件
    const register = Vue.extend({
      template: `&lt;div&gt;
        &lt;h3&gt;注册组件&lt;/h3&gt;
      &lt;/div&gt;`
    });
    Vue.component(&#39;register&#39;, register);

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: { comName: &#39;login&#39; },
      methods: {}
    });

</code></pre><ol start="2">
<li>使用<code>component</code>标签，来引用组件，并通过<code>:is</code>属性来指定要加载的组件：</li>
</ol>
<pre><code>  &lt;div id=&quot;app&quot;&gt;
    &lt;a href=&quot;#&quot; @click.prevent=&quot;comName=&#39;login&#39;&quot;&gt;登录&lt;/a&gt;
    &lt;a href=&quot;#&quot; @click.prevent=&quot;comName=&#39;register&#39;&quot;&gt;注册&lt;/a&gt;
    &lt;hr&gt;
    &lt;transition mode=&quot;out-in&quot;&gt;
      &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
    &lt;/transition&gt;
  &lt;/div&gt;

</code></pre><ol start="3">
<li>添加切换样式：</li>
</ol>
<pre><code>  &lt;style&gt;
    .v-enter,
    .v-leave-to {
      opacity: 0;
      transform: translateX(30px);
    }

    .v-enter-active,
    .v-leave-active {
      position: absolute;
      transition: all 0.3s ease;
    }

    h3{
      margin: 0;
    }
  &lt;/style&gt;

</code></pre><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol>
<li>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</li>
</ol>
<pre><code>&lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        msg: &#39;这是父组件中的消息&#39;
      },
      components: {
        son: {
          template: &#39;&lt;h1&gt;这是子组件 --- {{finfo}}&lt;/h1&gt;&#39;,
          props: [&#39;finfo&#39;]
        }
      }
    });
  &lt;/script&gt;

</code></pre><ol start="2">
<li>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt;
  &lt;/div&gt;

</code></pre><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><ol>
<li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li>
<li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</li>
</ol>
<pre><code>&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;

</code></pre><ol start="3">
<li>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;!-- 引用父组件 --&gt;
    &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;

    &lt;!-- 组件模板定义 --&gt;
    &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt;
      &lt;div&gt;
        &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt;
      &lt;/div&gt;
    &lt;/script&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 子组件的定义方式
    Vue.component(&#39;son&#39;, {
      template: &#39;#son&#39;, // 组件模板Id
      methods: {
        sendMsg() { // 按钮的点击事件
          this.$emit(&#39;func&#39;, &#39;OK&#39;); // 调用父组件传递过来的方法，同时把数据传递出去
        }
      }
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {
        getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义
          alert(val);
        }
      }
    });
  &lt;/script&gt;

</code></pre><h2 id="评论列表案例"><a href="#评论列表案例" class="headerlink" title="评论列表案例"></a>评论列表案例</h2><p>目标：主要练习父子组件之间传值</p>
<h2 id="使用-this-refs-来获取元素和组件"><a href="#使用-this-refs-来获取元素和组件" class="headerlink" title="使用 this.$refs 来获取元素和组件"></a>使用 <code>this.$refs</code> 来获取元素和组件</h2><pre><code>  &lt;div id=&quot;app&quot;&gt;
    &lt;div&gt;
      &lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&gt;
      &lt;!-- 使用 ref 获取元素 --&gt;
      &lt;h1 ref=&quot;myh1&quot;&gt;这是一个大大的H1&lt;/h1&gt;

      &lt;hr&gt;
      &lt;!-- 使用 ref 获取子组件 --&gt;
      &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script&gt;
    Vue.component(&#39;my-com&#39;, {
      template: &#39;&lt;h5&gt;这是一个子组件&lt;/h5&gt;&#39;,
      data() {
        return {
          name: &#39;子组件&#39;
        }
      }
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {
        getElement() {
          // 通过 this.$refs 来获取元素
          console.log(this.$refs.myh1.innerText);
          // 通过 this.$refs 来获取组件
          console.log(this.$refs.mycom.name);
        }
      }
    });
  &lt;/script&gt;

</code></pre><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><ol>
<li>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</li>
<li>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</li>
<li>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</li>
</ol>
<h2 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h2><ol>
<li>导入 vue-router 组件类库：</li>
</ol>
<pre><code>&lt;!-- 1. 导入 vue-router 组件类库 --&gt;
  &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt;

</code></pre><ol start="2">
<li>使用 router-link 组件来导航</li>
</ol>
<pre><code>&lt;!-- 2. 使用 router-link 组件来导航 --&gt;
&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;
&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;

</code></pre><ol start="3">
<li>使用 router-view 组件来显示匹配到的组件</li>
</ol>
<pre><code>&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;
&lt;router-view&gt;&lt;/router-view&gt;

</code></pre><ol start="4">
<li>创建使用<code>Vue.extend</code>创建组件</li>
</ol>
<pre><code>    // 4.1 使用 Vue.extend 来创建登录组件
    var login = Vue.extend({
      template: &#39;&lt;h1&gt;登录组件&lt;/h1&gt;&#39;
    });

    // 4.2 使用 Vue.extend 来创建注册组件
    var register = Vue.extend({
      template: &#39;&lt;h1&gt;注册组件&lt;/h1&gt;&#39;
    });

</code></pre><ol start="5">
<li>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</li>
</ol>
<pre><code>// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则
    var router = new VueRouter({
      routes: [
        { path: &#39;/login&#39;, component: login },
        { path: &#39;/register&#39;, component: register }
      ]
    });

</code></pre><ol start="6">
<li>使用 router 属性来使用路由规则</li>
</ol>
<pre><code>// 6. 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      router: router // 使用 router 属性来使用路由规则
    });

</code></pre><h2 id="设置路由高亮"><a href="#设置路由高亮" class="headerlink" title="设置路由高亮"></a>设置路由高亮</h2><h2 id="设置路由切换动效"><a href="#设置路由切换动效" class="headerlink" title="设置路由切换动效"></a>设置路由切换动效</h2><h2 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h2><ol>
<li>在规则中定义参数：</li>
</ol>
<pre><code>{ path: &#39;/register/:id&#39;, component: register }

</code></pre><ol start="2">
<li>通过 <code>this.$route.params</code>来获取路由中的参数：</li>
</ol>
<pre><code>var register = Vue.extend({
      template: &#39;&lt;h1&gt;注册组件 --- {{this.$route.params.id}}&lt;/h1&gt;&#39;
    });

</code></pre><h2 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h2><pre><code>  &lt;div id=&quot;app&quot;&gt;
    &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt;

    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 父路由中的组件
    const account = Vue.extend({
      template: `&lt;div&gt;
        这是account组件
        &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | 
        &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
      &lt;/div&gt;`
    });

    // 子路由中的 login 组件
    const login = Vue.extend({
      template: &#39;&lt;div&gt;登录组件&lt;/div&gt;&#39;
    });

    // 子路由中的 register 组件
    const register = Vue.extend({
      template: &#39;&lt;div&gt;注册组件&lt;/div&gt;&#39;
    });

    // 路由实例
    var router = new VueRouter({
      routes: [
        { path: &#39;/&#39;, redirect: &#39;/account/login&#39; }, // 使用 redirect 实现路由重定向
        {
          path: &#39;/account&#39;,
          component: account,
          children: [ // 通过 children 数组属性，来实现路由的嵌套
            { path: &#39;login&#39;, component: login }, // 注意，子路由的开头位置，不要加 / 路径符
            { path: &#39;register&#39;, component: register }
          ]
        }
      ]
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {},
      components: {
        account
      },
      router: router
    });
  &lt;/script&gt;

</code></pre><h2 id="命名视图实现经典布局"><a href="#命名视图实现经典布局" class="headerlink" title="命名视图实现经典布局"></a>命名视图实现经典布局</h2><ol>
<li>标签代码结构：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
    &lt;div class=&quot;content&quot;&gt;
      &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;
      &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;

</code></pre><ol start="2">
<li>JS代码：</li>
</ol>
<pre><code>&lt;script&gt;
    var header = Vue.component(&#39;header&#39;, {
      template: &#39;&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;&#39;
    });

    var sidebar = Vue.component(&#39;sidebar&#39;, {
      template: &#39;&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;&#39;
    });

    var mainbox = Vue.component(&#39;mainbox&#39;, {
      template: &#39;&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;&#39;
    });

    // 创建路由对象
    var router = new VueRouter({
      routes: [
        {
          path: &#39;/&#39;, components: {
            default: header,
            a: sidebar,
            b: mainbox
          }
        }
      ]
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {},
      router
    });
  &lt;/script&gt;

</code></pre><ol start="3">
<li>CSS 样式：</li>
</ol>
<pre><code>  &lt;style&gt;
    .header {
      border: 1px solid red;
    }

    .content{
      display: flex;
    }
    .sidebar {
      flex: 2;
      border: 1px solid green;
      height: 500px;
    }
    .mainbox{
      flex: 8;
      border: 1px solid blue;
      height: 500px;
    }
  &lt;/style&gt;

</code></pre><h2 id="watch属性的使用"><a href="#watch属性的使用" class="headerlink" title="watch属性的使用"></a><code>watch</code>属性的使用</h2><p>考虑一个问题：想要实现 <code>名</code> 和 <code>姓</code> 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）</p>
<ol>
<li>监听<code>data</code>中属性的改变：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; +
    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; =
    &lt;span&gt;{{fullName}}&lt;/span&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        firstName: &#39;jack&#39;,
        lastName: &#39;chen&#39;,
        fullName: &#39;jack - chen&#39;
      },
      methods: {},
      watch: {
        &#39;firstName&#39;: function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据
          this.fullName = newVal + &#39; - &#39; + this.lastName;
        },
        &#39;lastName&#39;: function (newVal, oldVal) {
          this.fullName = this.firstName + &#39; - &#39; + newVal;
        }
      }
    });
  &lt;/script&gt;

</code></pre><ol start="2">
<li>监听路由对象的改变：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;
    &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;

    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;

  &lt;script&gt;
    var login = Vue.extend({
      template: &#39;&lt;h1&gt;登录组件&lt;/h1&gt;&#39;
    });

    var register = Vue.extend({
      template: &#39;&lt;h1&gt;注册组件&lt;/h1&gt;&#39;
    });

    var router = new VueRouter({
      routes: [
        { path: &quot;/login&quot;, component: login },
        { path: &quot;/register&quot;, component: register }
      ]
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {},
      router: router,
      watch: {
        &#39;$route&#39;: function (newVal, oldVal) {
          if (newVal.path === &#39;/login&#39;) {
            console.log(&#39;这是登录组件&#39;);
          }
        }
      }
    });
  &lt;/script&gt;

</code></pre><h2 id="computed计算属性的使用"><a href="#computed计算属性的使用" class="headerlink" title="computed计算属性的使用"></a><code>computed</code>计算属性的使用</h2><ol>
<li>默认只有<code>getter</code>的计算属性：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; +
    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; =
    &lt;span&gt;{{fullName}}&lt;/span&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        firstName: &#39;jack&#39;,
        lastName: &#39;chen&#39;
      },
      methods: {},
      computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值
        fullName() {
          return this.firstName + &#39; - &#39; + this.lastName;
        }
      }
    });
  &lt;/script&gt;

</code></pre><ol start="2">
<li>定义有<code>getter</code>和<code>setter</code>的计算属性：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;
    &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt;
    &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt;

    &lt;span&gt;{{fullName}}&lt;/span&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        firstName: &#39;jack&#39;,
        lastName: &#39;chen&#39;
      },
      methods: {
        changeName() {
          this.fullName = &#39;TOM - chen2&#39;;
        }
      },
      computed: {
        fullName: {
          get: function () {
            return this.firstName + &#39; - &#39; + this.lastName;
          },
          set: function (newVal) {
            var parts = newVal.split(&#39; - &#39;);
            this.firstName = parts[0];
            this.lastName = parts[1];
          }
        }
      }
    });
  &lt;/script&gt;
</code></pre><h2 id="watch、computed和methods之间的对比"><a href="#watch、computed和methods之间的对比" class="headerlink" title="watch、computed和methods之间的对比"></a><code>watch</code>、<code>computed</code>和<code>methods</code>之间的对比</h2><ol>
<li><code>computed</code>属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li>
<li><code>methods</code>方法表示一个具体的操作，主要书写业务逻辑；</li>
<li><code>watch</code>一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是<code>computed</code>和<code>methods</code>的结合体；</li>
</ol>
<h2 id="nrm的安装使用"><a href="#nrm的安装使用" class="headerlink" title="nrm的安装使用"></a><code>nrm</code>的安装使用</h2><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；<br>什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；</p>
<ol>
<li>运行<code>npm i nrm -g</code>全局安装<code>nrm</code>包；</li>
<li>使用<code>nrm ls</code>查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</li>
<li>使用<code>nrm use npm</code>或<code>nrm use taobao</code>切换不同的镜像源地址；</li>
</ol>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ol>
<li><a href="http://www.cnblogs.com/joyho/articles/4430148.html" target="_blank" rel="noopener">URL中的hash（井号）</a></li>
</ol>
<h1 id="Vue-js-Day4"><a href="#Vue-js-Day4" class="headerlink" title="Vue.js - Day4"></a>Vue.js - Day4</h1><h2 id="父组件向子组件传值-1"><a href="#父组件向子组件传值-1" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol>
<li>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</li>
</ol>
<pre><code>&lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        msg: &#39;这是父组件中的消息&#39;
      },
      components: {
        son: {
          template: &#39;&lt;h1&gt;这是子组件 --- {{finfo}}&lt;/h1&gt;&#39;,
          props: [&#39;finfo&#39;]
        }
      }
    });
  &lt;/script&gt;
</code></pre><ol start="2">
<li>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt;
  &lt;/div&gt;
</code></pre><h2 id="子组件向父组件传值-1"><a href="#子组件向父组件传值-1" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><ol>
<li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li>
<li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</li>
</ol>
<pre><code>&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;
</code></pre><ol start="3">
<li>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;!-- 引用父组件 --&gt;
    &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;

    &lt;!-- 组件模板定义 --&gt;
    &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt;
      &lt;div&gt;
        &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt;
      &lt;/div&gt;
    &lt;/script&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 子组件的定义方式
    Vue.component(&#39;son&#39;, {
      template: &#39;#son&#39;, // 组件模板Id
      methods: {
        sendMsg() { // 按钮的点击事件
          this.$emit(&#39;func&#39;, &#39;OK&#39;); // 调用父组件传递过来的方法，同时把数据传递出去
        }
      }
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {
        getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义
          alert(val);
        }
      }
    });
  &lt;/script&gt;
</code></pre><h2 id="组件中data和props的区别"><a href="#组件中data和props的区别" class="headerlink" title="组件中data和props的区别"></a>组件中data和props的区别</h2><h2 id="评论列表案例-1"><a href="#评论列表案例-1" class="headerlink" title="评论列表案例"></a>评论列表案例</h2><p>目标：主要练习父子组件之间传值</p>
<h2 id="使用-this-refs-来获取元素和组件-1"><a href="#使用-this-refs-来获取元素和组件-1" class="headerlink" title="使用 this.$refs 来获取元素和组件"></a>使用 <code>this.$refs</code> 来获取元素和组件</h2><pre><code>  &lt;div id=&quot;app&quot;&gt;
    &lt;div&gt;
      &lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&gt;
      &lt;!-- 使用 ref 获取元素 --&gt;
      &lt;h1 ref=&quot;myh1&quot;&gt;这是一个大大的H1&lt;/h1&gt;

      &lt;hr&gt;
      &lt;!-- 使用 ref 获取子组件 --&gt;
      &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script&gt;
    Vue.component(&#39;my-com&#39;, {
      template: &#39;&lt;h5&gt;这是一个子组件&lt;/h5&gt;&#39;,
      data() {
        return {
          name: &#39;子组件&#39;
        }
      }
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {
        getElement() {
          // 通过 this.$refs 来获取元素
          console.log(this.$refs.myh1.innerText);
          // 通过 this.$refs 来获取组件
          console.log(this.$refs.mycom.name);
        }
      }
    });
  &lt;/script&gt;
</code></pre><h2 id="什么是路由-1"><a href="#什么是路由-1" class="headerlink" title="什么是路由"></a>什么是路由</h2><ol>
<li><strong>后端路由：</strong>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</li>
<li><strong>前端路由：</strong>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</li>
<li>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</li>
</ol>
<h2 id="在-vue-中使用-vue-router-1"><a href="#在-vue-中使用-vue-router-1" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h2><ol>
<li>导入 vue-router 组件类库：</li>
</ol>
<pre><code>&lt;!-- 1. 导入 vue-router 组件类库 --&gt;
  &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt;
</code></pre><ol start="2">
<li>使用 router-link 组件来导航</li>
</ol>
<pre><code>&lt;!-- 2. 使用 router-link 组件来导航 --&gt;
&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;
&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;
</code></pre><ol start="3">
<li>使用 router-view 组件来显示匹配到的组件</li>
</ol>
<pre><code>&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;
&lt;router-view&gt;&lt;/router-view&gt;
</code></pre><ol start="4">
<li>创建使用<code>Vue.extend</code>创建组件</li>
</ol>
<pre><code>    // 4.1 使用 Vue.extend 来创建登录组件
    var login = Vue.extend({
      template: &#39;&lt;h1&gt;登录组件&lt;/h1&gt;&#39;
    });

    // 4.2 使用 Vue.extend 来创建注册组件
    var register = Vue.extend({
      template: &#39;&lt;h1&gt;注册组件&lt;/h1&gt;&#39;
    });

</code></pre><ol start="5">
<li>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</li>
</ol>
<pre><code>// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则
    var router = new VueRouter({
      routes: [
        { path: &#39;/login&#39;, component: login },
        { path: &#39;/register&#39;, component: register }
      ]
    });

</code></pre><ol start="6">
<li>使用 router 属性来使用路由规则</li>
</ol>
<pre><code>// 6. 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      router: router // 使用 router 属性来使用路由规则
    });

</code></pre><h2 id="使用tag属性指定router-link渲染的标签类型"><a href="#使用tag属性指定router-link渲染的标签类型" class="headerlink" title="使用tag属性指定router-link渲染的标签类型"></a>使用tag属性指定router-link渲染的标签类型</h2><h2 id="设置路由重定向"><a href="#设置路由重定向" class="headerlink" title="设置路由重定向"></a>设置路由重定向</h2><h2 id="设置路由高亮-1"><a href="#设置路由高亮-1" class="headerlink" title="设置路由高亮"></a>设置路由高亮</h2><h2 id="设置路由切换动效-1"><a href="#设置路由切换动效-1" class="headerlink" title="设置路由切换动效"></a>设置路由切换动效</h2><h2 id="在路由规则中定义参数-1"><a href="#在路由规则中定义参数-1" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h2><ol>
<li>在规则中定义参数：</li>
</ol>
<pre><code>{ path: &#39;/register/:id&#39;, component: register }

</code></pre><ol start="2">
<li>通过 <code>this.$route.params</code>来获取路由中的参数：</li>
</ol>
<pre><code>var register = Vue.extend({
      template: &#39;&lt;h1&gt;注册组件 --- {{this.$route.params.id}}&lt;/h1&gt;&#39;
    });

</code></pre><h2 id="使用-children-属性实现路由嵌套-1"><a href="#使用-children-属性实现路由嵌套-1" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h2><pre><code>  &lt;div id=&quot;app&quot;&gt;
    &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt;

    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 父路由中的组件
    const account = Vue.extend({
      template: `&lt;div&gt;
        这是account组件
        &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | 
        &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
      &lt;/div&gt;`
    });

    // 子路由中的 login 组件
    const login = Vue.extend({
      template: &#39;&lt;div&gt;登录组件&lt;/div&gt;&#39;
    });

    // 子路由中的 register 组件
    const register = Vue.extend({
      template: &#39;&lt;div&gt;注册组件&lt;/div&gt;&#39;
    });

    // 路由实例
    var router = new VueRouter({
      routes: [
        { path: &#39;/&#39;, redirect: &#39;/account/login&#39; }, // 使用 redirect 实现路由重定向
        {
          path: &#39;/account&#39;,
          component: account,
          children: [ // 通过 children 数组属性，来实现路由的嵌套
            { path: &#39;login&#39;, component: login }, // 注意，子路由的开头位置，不要加 / 路径符
            { path: &#39;register&#39;, component: register }
          ]
        }
      ]
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {},
      components: {
        account
      },
      router: router
    });
  &lt;/script&gt;

</code></pre><h2 id="命名视图实现经典布局-1"><a href="#命名视图实现经典布局-1" class="headerlink" title="命名视图实现经典布局"></a>命名视图实现经典布局</h2><ol>
<li>标签代码结构：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
    &lt;div class=&quot;content&quot;&gt;
      &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;
      &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;

</code></pre><ol start="2">
<li>JS代码：</li>
</ol>
<pre><code>&lt;script&gt;
    var header = Vue.component(&#39;header&#39;, {
      template: &#39;&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;&#39;
    });

    var sidebar = Vue.component(&#39;sidebar&#39;, {
      template: &#39;&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;&#39;
    });

    var mainbox = Vue.component(&#39;mainbox&#39;, {
      template: &#39;&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;&#39;
    });

    // 创建路由对象
    var router = new VueRouter({
      routes: [
        {
          path: &#39;/&#39;, components: {
            default: header,
            a: sidebar,
            b: mainbox
          }
        }
      ]
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {},
      router
    });
  &lt;/script&gt;

</code></pre><ol start="3">
<li>CSS 样式：</li>
</ol>
<pre><code>  &lt;style&gt;
    .header {
      border: 1px solid red;
    }

    .content{
      display: flex;
    }
    .sidebar {
      flex: 2;
      border: 1px solid green;
      height: 500px;
    }
    .mainbox{
      flex: 8;
      border: 1px solid blue;
      height: 500px;
    }
  &lt;/style&gt;

</code></pre><h2 id="watch属性的使用-1"><a href="#watch属性的使用-1" class="headerlink" title="watch属性的使用"></a><code>watch</code>属性的使用</h2><p>考虑一个问题：想要实现 <code>名</code> 和 <code>姓</code> 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）</p>
<ol>
<li>监听<code>data</code>中属性的改变：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; +
    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; =
    &lt;span&gt;{{fullName}}&lt;/span&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        firstName: &#39;jack&#39;,
        lastName: &#39;chen&#39;,
        fullName: &#39;jack - chen&#39;
      },
      methods: {},
      watch: {
        &#39;firstName&#39;: function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据
          this.fullName = newVal + &#39; - &#39; + this.lastName;
        },
        &#39;lastName&#39;: function (newVal, oldVal) {
          this.fullName = this.firstName + &#39; - &#39; + newVal;
        }
      }
    });
  &lt;/script&gt;

</code></pre><ol start="2">
<li>监听路由对象的改变：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;
    &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;

    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;

  &lt;script&gt;
    var login = Vue.extend({
      template: &#39;&lt;h1&gt;登录组件&lt;/h1&gt;&#39;
    });

    var register = Vue.extend({
      template: &#39;&lt;h1&gt;注册组件&lt;/h1&gt;&#39;
    });

    var router = new VueRouter({
      routes: [
        { path: &quot;/login&quot;, component: login },
        { path: &quot;/register&quot;, component: register }
      ]
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {},
      methods: {},
      router: router,
      watch: {
        &#39;$route&#39;: function (newVal, oldVal) {
          if (newVal.path === &#39;/login&#39;) {
            console.log(&#39;这是登录组件&#39;);
          }
        }
      }
    });
  &lt;/script&gt;

</code></pre><h2 id="computed计算属性的使用-1"><a href="#computed计算属性的使用-1" class="headerlink" title="computed计算属性的使用"></a><code>computed</code>计算属性的使用</h2><ol>
<li>默认只有<code>getter</code>的计算属性：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; +
    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; =
    &lt;span&gt;{{fullName}}&lt;/span&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        firstName: &#39;jack&#39;,
        lastName: &#39;chen&#39;
      },
      methods: {},
      computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值
        fullName() {
          return this.firstName + &#39; - &#39; + this.lastName;
        }
      }
    });
  &lt;/script&gt;

</code></pre><ol start="2">
<li>定义有<code>getter</code>和<code>setter</code>的计算属性：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;
    &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt;
    &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt;

    &lt;span&gt;{{fullName}}&lt;/span&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        firstName: &#39;jack&#39;,
        lastName: &#39;chen&#39;
      },
      methods: {
        changeName() {
          this.fullName = &#39;TOM - chen2&#39;;
        }
      },
      computed: {
        fullName: {
          get: function () {
            return this.firstName + &#39; - &#39; + this.lastName;
          },
          set: function (newVal) {
            var parts = newVal.split(&#39; - &#39;);
            this.firstName = parts[0];
            this.lastName = parts[1];
          }
        }
      }
    });
  &lt;/script&gt;

</code></pre><h2 id="watch、computed和methods之间的对比-1"><a href="#watch、computed和methods之间的对比-1" class="headerlink" title="watch、computed和methods之间的对比"></a><code>watch</code>、<code>computed</code>和<code>methods</code>之间的对比</h2><ol>
<li><code>computed</code>属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li>
<li><code>methods</code>方法表示一个具体的操作，主要书写业务逻辑；</li>
<li><code>watch</code>一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是<code>computed</code>和<code>methods</code>的结合体；</li>
</ol>
<h2 id="nrm的安装使用-1"><a href="#nrm的安装使用-1" class="headerlink" title="nrm的安装使用"></a><code>nrm</code>的安装使用</h2><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；<br>什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；</p>
<ol>
<li>运行<code>npm i nrm -g</code>全局安装<code>nrm</code>包；</li>
<li>使用<code>nrm ls</code>查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</li>
<li>使用<code>nrm use npm</code>或<code>nrm use taobao</code>切换不同的镜像源地址；</li>
</ol>
<h2 id="相关文件-1"><a href="#相关文件-1" class="headerlink" title="相关文件"></a>相关文件</h2><ol>
<li><a href="http://www.cnblogs.com/joyho/articles/4430148.html" target="_blank" rel="noopener">URL中的hash（井号）</a></li>
</ol>
<h1 id="Vue-js-Day5-Webpack"><a href="#Vue-js-Day5-Webpack" class="headerlink" title="Vue.js - Day5 - Webpack"></a>Vue.js - Day5 - Webpack</h1><h2 id="在网页中会引用哪些常见的静态资源？"><a href="#在网页中会引用哪些常见的静态资源？" class="headerlink" title="在网页中会引用哪些常见的静态资源？"></a>在网页中会引用哪些常见的静态资源？</h2><ul>
<li>JS</li>
<li>.js  .jsx  .coffee  .ts（TypeScript  类 C# 语言）</li>
<li>CSS</li>
<li>.css  .less   .sass  .scss</li>
<li>Images</li>
<li>.jpg   .png   .gif   .bmp   .svg</li>
<li>字体文件（Fonts）</li>
<li>.svg   .ttf   .eot   .woff   .woff2</li>
<li>模板文件</li>
<li>.ejs   .jade  .vue【这是在webpack中定义组件的方式，推荐这么用】</li>
</ul>
<h2 id="网页中引入的静态资源多了以后有什么问题？？？"><a href="#网页中引入的静态资源多了以后有什么问题？？？" class="headerlink" title="网页中引入的静态资源多了以后有什么问题？？？"></a>网页中引入的静态资源多了以后有什么问题？？？</h2><ol>
<li>网页加载速度慢， 因为 我们要发起很多的二次请求；</li>
<li>要处理错综复杂的依赖关系</li>
</ol>
<h2 id="如何解决上述两个问题"><a href="#如何解决上述两个问题" class="headerlink" title="如何解决上述两个问题"></a>如何解决上述两个问题</h2><ol>
<li>合并、压缩、精灵图、图片的Base64编码</li>
<li>可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；</li>
</ol>
<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack?"></a>什么是webpack?</h2><p>webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；</p>
<h2 id="如何完美实现上述的2种解决方案"><a href="#如何完美实现上述的2种解决方案" class="headerlink" title="如何完美实现上述的2种解决方案"></a>如何完美实现上述的2种解决方案</h2><ol>
<li>使用Gulp， 是基于 task 任务的；</li>
<li>使用Webpack， 是基于整个项目进行构建的；</li>
</ol>
<ul>
<li>借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。</li>
<li>根据官网的图片介绍webpack打包的过程</li>
<li><a href="http://webpack.github.io/" target="_blank" rel="noopener">webpack官网</a></li>
</ul>
<h2 id="webpack安装的两种方式"><a href="#webpack安装的两种方式" class="headerlink" title="webpack安装的两种方式"></a>webpack安装的两种方式</h2><ol>
<li>运行<code>npm i webpack -g</code>全局安装webpack，这样就能在全局使用webpack的命令</li>
<li>在项目根目录中运行<code>npm i webpack --save-dev</code>安装到项目依赖中</li>
</ol>
<h2 id="初步使用webpack打包构建列表隔行变色案例"><a href="#初步使用webpack打包构建列表隔行变色案例" class="headerlink" title="初步使用webpack打包构建列表隔行变色案例"></a>初步使用webpack打包构建列表隔行变色案例</h2><ol>
<li>运行<code>npm init</code>初始化项目，使用npm管理项目中的依赖包</li>
<li>创建项目基本的目录结构</li>
<li>使用<code>cnpm i jquery --save</code>安装jquery类库</li>
<li>创建<code>main.js</code>并书写各行变色的代码逻辑：</li>
</ol>
<pre><code>    // 导入jquery类库
    import $ from &#39;jquery&#39;

    // 设置偶数行背景色，索引从0开始，0是偶数
    $(&#39;#list li:even&#39;).css(&#39;backgroundColor&#39;,&#39;lightblue&#39;);
    // 设置奇数行背景色
    $(&#39;#list li:odd&#39;).css(&#39;backgroundColor&#39;,&#39;pink&#39;);
</code></pre><ol start="5">
<li>直接在页面上引用<code>main.js</code>会报错，因为浏览器不认识<code>import</code>这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；</li>
<li>运行<code>webpack 入口文件路径 输出文件路径</code>对<code>main.js</code>进行处理：</li>
</ol>
<pre><code>webpack src/js/main.js dist/bundle.js
</code></pre><h2 id="使用webpack的配置文件简化打包时候的命令"><a href="#使用webpack的配置文件简化打包时候的命令" class="headerlink" title="使用webpack的配置文件简化打包时候的命令"></a>使用webpack的配置文件简化打包时候的命令</h2><ol>
<li>在项目根目录中创建<code>webpack.config.js</code></li>
<li>由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在<code>webpack.config.js</code>中配置这两个路径：</li>
</ol>
<pre><code>    // 导入处理路径的模块
    var path = require(&#39;path&#39;);

    // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理
    module.exports = {
        entry: path.resolve(__dirname, &#39;src/js/main.js&#39;), // 项目入口文件
        output: { // 配置输出选项
            path: path.resolve(__dirname, &#39;dist&#39;), // 配置输出的路径
            filename: &#39;bundle.js&#39; // 配置输出的文件名
        }
    }
</code></pre><h2 id="实现webpack的实时打包构建"><a href="#实现webpack的实时打包构建" class="headerlink" title="实现webpack的实时打包构建"></a>实现webpack的实时打包构建</h2><ol>
<li>由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用<code>webpack-dev-server</code>来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。</li>
<li>运行<code>cnpm i webpack-dev-server --save-dev</code>安装到开发依赖</li>
<li>安装完成之后，在命令行直接运行<code>webpack-dev-server</code>来进行打包，发现报错，此时需要借助于<code>package.json</code>文件中的指令，来进行运行<code>webpack-dev-server</code>命令，在<code>scripts</code>节点下新增<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>指令，发现可以进行实时打包，但是dist目录下并没有生成<code>bundle.js</code>文件，这是因为<code>webpack-dev-server</code>将打包好的文件放在了内存中</li>
</ol>
<ul>
<li>把<code>bundle.js</code>放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快</li>
<li>这个时候访问webpack-dev-server启动的<code>http://localhost:8080/</code>网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:<code>&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;</code></li>
<li>为了能在访问<code>http://localhost:8080/</code>的时候直接访问到index首页，可以使用<code>--contentBase src</code>指令来修改dev指令，指定启动的根目录：</li>
</ul>
<pre><code> &quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot;
</code></pre><p> 同时修改index页面中script的src属性为<code>&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</code></p>
<h2 id="使用html-webpack-plugin插件配置启动页面"><a href="#使用html-webpack-plugin插件配置启动页面" class="headerlink" title="使用html-webpack-plugin插件配置启动页面"></a>使用<code>html-webpack-plugin</code>插件配置启动页面</h2><p>由于使用<code>--contentBase</code>指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用<code>html-webpack-plugin</code>插件配置启动页面.</p>
<ol>
<li>运行<code>cnpm i html-webpack-plugin --save-dev</code>安装到开发依赖</li>
<li>修改<code>webpack.config.js</code>配置文件如下：</li>
</ol>
<pre><code>    // 导入处理路径的模块
    var path = require(&#39;path&#39;);
    // 导入自动生成HTMl文件的插件
    var htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

    module.exports = {
        entry: path.resolve(__dirname, &#39;src/js/main.js&#39;), // 项目入口文件
        output: { // 配置输出选项
            path: path.resolve(__dirname, &#39;dist&#39;), // 配置输出的路径
            filename: &#39;bundle.js&#39; // 配置输出的文件名
        },
        plugins:[ // 添加plugins节点配置插件
            new htmlWebpackPlugin({
                template:path.resolve(__dirname, &#39;src/index.html&#39;),//模板路径
                filename:&#39;index.html&#39;//自动生成的HTML文件的名称
            })
        ]
    }
</code></pre><ol start="3">
<li>修改<code>package.json</code>中<code>script</code>节点中的dev指令如下：</li>
</ol>
<pre><code>&quot;dev&quot;: &quot;webpack-dev-server&quot;
</code></pre><ol start="4">
<li>将index.html中script标签注释掉，因为<code>html-webpack-plugin</code>插件会自动把bundle.js注入到index.html页面中！</li>
</ol>
<h2 id="实现自动打开浏览器、热更新和配置浏览器的默认端口号"><a href="#实现自动打开浏览器、热更新和配置浏览器的默认端口号" class="headerlink" title="实现自动打开浏览器、热更新和配置浏览器的默认端口号"></a>实现自动打开浏览器、热更新和配置浏览器的默认端口号</h2><p><strong>注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！</strong></p>
<h3 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h3><ul>
<li>修改<code>package.json</code>的script节点如下，其中<code>--open</code>表示自动打开浏览器，<code>--port 4321</code>表示打开的端口号为4321，<code>--hot</code>表示启用浏览器热更新：</li>
</ul>
<pre><code>&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot;
</code></pre><h3 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h3><ol>
<li>修改<code>webpack.config.js</code>文件，新增<code>devServer</code>节点如下：</li>
</ol>
<pre><code>devServer:{
        hot:true,
        open:true,
        port:4321
    }
</code></pre><ol start="2">
<li>在头部引入<code>webpack</code>模块：</li>
</ol>
<pre><code>var webpack = require(&#39;webpack&#39;);

</code></pre><ol start="3">
<li>在<code>plugins</code>节点下新增：</li>
</ol>
<pre><code>new webpack.HotModuleReplacementPlugin()

</code></pre><h2 id="使用webpack打包css文件"><a href="#使用webpack打包css文件" class="headerlink" title="使用webpack打包css文件"></a>使用webpack打包css文件</h2><ol>
<li>运行<code>cnpm i style-loader css-loader --save-dev</code></li>
<li>修改<code>webpack.config.js</code>这个配置文件：</li>
</ol>
<pre><code>module: { // 用来配置第三方loader模块的
        rules: [ // 文件的匹配规则
            { test: /\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] }//处理css文件的规则
        ]
    }

</code></pre><ol start="3">
<li>注意：<code>use</code>表示使用哪些模块来处理<code>test</code>所匹配到的文件；<code>use</code>中相关loader模块的调用顺序是从后向前调用的；</li>
</ol>
<h2 id="使用webpack打包less文件"><a href="#使用webpack打包less文件" class="headerlink" title="使用webpack打包less文件"></a>使用webpack打包less文件</h2><ol>
<li>运行<code>cnpm i less-loader less -D</code></li>
<li>修改<code>webpack.config.js</code>这个配置文件：</li>
</ol>
<pre><code>{ test: /\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] },

</code></pre><h2 id="使用webpack打包sass文件"><a href="#使用webpack打包sass文件" class="headerlink" title="使用webpack打包sass文件"></a>使用webpack打包sass文件</h2><ol>
<li>运行<code>cnpm i sass-loader node-sass --save-dev</code></li>
<li>在<code>webpack.config.js</code>中添加处理sass文件的loader模块：</li>
</ol>
<pre><code>{ test: /\.scss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] }

</code></pre><h2 id="使用webpack处理css中的路径"><a href="#使用webpack处理css中的路径" class="headerlink" title="使用webpack处理css中的路径"></a>使用webpack处理css中的路径</h2><ol>
<li>运行<code>cnpm i url-loader file-loader --save-dev</code></li>
<li>在<code>webpack.config.js</code>中添加处理url路径的loader模块：</li>
</ol>
<pre><code>{ test: /\.(png|jpg|gif)$/, use: &#39;url-loader&#39; }

</code></pre><ol start="3">
<li>可以通过<code>limit</code>指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：</li>
</ol>
<pre><code>{ test: /\.(png|jpg|gif)$/, use: &#39;url-loader?limit=43960&#39; },

</code></pre><h2 id="使用babel处理高级JS语法"><a href="#使用babel处理高级JS语法" class="headerlink" title="使用babel处理高级JS语法"></a>使用babel处理高级JS语法</h2><ol>
<li>运行<code>cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev</code>安装babel的相关loader包</li>
<li>运行<code>cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev</code>安装babel转换的语法</li>
<li>在<code>webpack.config.js</code>中添加相关loader模块，其中需要注意的是，一定要把<code>node_modules</code>文件夹添加到排除项：</li>
</ol>
<pre><code>{ test: /\.js$/, use: &#39;babel-loader&#39;, exclude: /node_modules/ }

</code></pre><ol start="4">
<li>在项目根目录中添加<code>.babelrc</code>文件，并修改这个配置文件如下：</li>
</ol>
<pre><code>{
    &quot;presets&quot;:[&quot;es2015&quot;, &quot;stage-0&quot;],
    &quot;plugins&quot;:[&quot;transform-runtime&quot;]
}
</code></pre><ol start="5">
<li><strong>注意：语法插件<code>babel-preset-es2015</code>可以更新为<code>babel-preset-env</code>，它包含了所有的ES相关的语法；</strong></li>
</ol>
<h2 id="相关文章-2"><a href="#相关文章-2" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://segmentfault.com/p/1210000008466178" target="_blank" rel="noopener">babel-preset-env：你需要的唯一Babel插件</a><br><a href="https://segmentfault.com/a/1190000009065987" target="_blank" rel="noopener">Runtime transform 运行时编译es6</a></p>
<h1 id="Vue-js-day6"><a href="#Vue-js-day6" class="headerlink" title="Vue.js - day6"></a>Vue.js - day6</h1><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>有时候使用<code>npm i node-sass -D</code>装不上，这时候，就必须使用 <code>cnpm i node-sass -D</code></p>
<h2 id="在普通页面中使用render函数渲染组件"><a href="#在普通页面中使用render函数渲染组件" class="headerlink" title="在普通页面中使用render函数渲染组件"></a>在普通页面中使用render函数渲染组件</h2><h2 id="在webpack中配置-vue组件页面的解析"><a href="#在webpack中配置-vue组件页面的解析" class="headerlink" title="在webpack中配置.vue组件页面的解析"></a>在webpack中配置.vue组件页面的解析</h2><ol>
<li>运行<code>cnpm i vue -S</code>将vue安装为运行依赖；</li>
<li>运行<code>cnpm i vue-loader vue-template-compiler -D</code>将解析转换vue的包安装为开发依赖；</li>
<li>运行<code>cnpm i style-loader css-loader -D</code>将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式；</li>
<li>在<code>webpack.config.js</code>中，添加如下<code>module</code>规则：</li>
</ol>
<pre><code>module: {

    rules: [

      { test: /\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] },

      { test: /\.vue$/, use: &#39;vue-loader&#39; }

    ]

  }

</code></pre><ol start="5">
<li>创建<code>App.js</code>组件页面：</li>
</ol>
<pre><code>    &lt;template&gt;

      &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt;

      &lt;div&gt;

        &lt;h1&gt;这是APP组件 - {{msg}}&lt;/h1&gt;

        &lt;h3&gt;我是h3&lt;/h3&gt;

      &lt;/div&gt;

    &lt;/template&gt;



    &lt;script&gt;

    // 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象

    export default {

      data() {

        return {

          msg: &#39;OK&#39;

        }

      }

    }

    &lt;/script&gt;



    &lt;style scoped&gt;

    h1 {

      color: red;

    }

    &lt;/style&gt;

</code></pre><ol start="6">
<li>创建<code>main.js</code>入口文件：</li>
</ol>
<pre><code>    // 导入 Vue 组件

    import Vue from &#39;vue&#39;



    // 导入 App组件

    import App from &#39;./components/App.vue&#39;



    // 创建一个 Vue 实例，使用 render 函数，渲染指定的组件

    var vm = new Vue({

      el: &#39;#app&#39;,

      render: c =&gt; c(App)

    });

</code></pre><h2 id="在使用webpack构建的Vue项目中使用模板对象？"><a href="#在使用webpack构建的Vue项目中使用模板对象？" class="headerlink" title="在使用webpack构建的Vue项目中使用模板对象？"></a>在使用webpack构建的Vue项目中使用模板对象？</h2><ol>
<li>在<code>webpack.config.js</code>中添加<code>resolve</code>属性：</li>
</ol>
<pre><code>resolve: {
    alias: {
      &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;
    }
  }
</code></pre><h2 id="ES6中语法使用总结"><a href="#ES6中语法使用总结" class="headerlink" title="ES6中语法使用总结"></a>ES6中语法使用总结</h2><ol>
<li>使用 <code>export default</code> 和 <code>export</code> 导出模块中的成员; 对应ES5中的 <code>module.exports</code> 和 <code>export</code></li>
<li>使用 <code>import ** from **</code> 和 <code>import &#39;路径&#39;</code> 还有 <code>import {a, b} from &#39;模块标识&#39;</code> 导入其他模块</li>
<li>使用箭头函数：<code>(a, b)=&gt; { return a-b; }</code></li>
</ol>
<h2 id="在vue组件页面中，集成vue-router路由模块"><a href="#在vue组件页面中，集成vue-router路由模块" class="headerlink" title="在vue组件页面中，集成vue-router路由模块"></a>在vue组件页面中，集成vue-router路由模块</h2><p><a href="https://router.vuejs.org/" target="_blank" rel="noopener">vue-router官网</a></p>
<ol>
<li>导入路由模块：</li>
</ol>
<pre><code>import VueRouter from &#39;vue-router&#39;

</code></pre><ol start="2">
<li>安装路由模块：</li>
</ol>
<pre><code>Vue.use(VueRouter);

</code></pre><ol start="3">
<li>导入需要展示的组件:</li>
</ol>
<pre><code>import login from &#39;./components/account/login.vue&#39;

import register from &#39;./components/account/register.vue&#39;

</code></pre><ol start="4">
<li>创建路由对象:</li>
</ol>
<pre><code>var router = new VueRouter({

  routes: [

    { path: &#39;/&#39;, redirect: &#39;/login&#39; },

    { path: &#39;/login&#39;, component: login },

    { path: &#39;/register&#39;, component: register }

  ]

});

</code></pre><ol start="5">
<li>将路由对象，挂载到 Vue 实例上:</li>
</ol>
<pre><code>var vm = new Vue({

  el: &#39;#app&#39;,

  // render: c =&gt; { return c(App) }

  render(c) {

    return c(App);

  },

  router // 将路由对象，挂载到 Vue 实例上

});


</code></pre><ol start="6">
<li>改造App.vue组件，在 template 中，添加<code>router-link</code>和<code>router-view</code>：</li>
</ol>
<pre><code>    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;

    &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;



    &lt;router-view&gt;&lt;/router-view&gt;


</code></pre><h2 id="组件中的css作用域问题"><a href="#组件中的css作用域问题" class="headerlink" title="组件中的css作用域问题"></a>组件中的css作用域问题</h2><h2 id="抽离路由为单独的模块"><a href="#抽离路由为单独的模块" class="headerlink" title="抽离路由为单独的模块"></a>抽离路由为单独的模块</h2><h2 id="使用-饿了么的-MintUI-组件"><a href="#使用-饿了么的-MintUI-组件" class="headerlink" title="使用 饿了么的 MintUI 组件"></a>使用 饿了么的 MintUI 组件</h2><p><a href="https://github.com/ElemeFE/mint-ui" target="_blank" rel="noopener">Github 仓储地址</a></p>
<p><a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">Mint-UI官方文档</a></p>
<ol>
<li>导入所有MintUI组件：</li>
</ol>
<pre><code>import MintUI from &#39;mint-ui&#39;


</code></pre><ol start="2">
<li>导入样式表：</li>
</ol>
<pre><code>import &#39;mint-ui/lib/style.css&#39;


</code></pre><ol start="3">
<li>在 vue 中使用 MintUI：</li>
</ol>
<pre><code>Vue.use(MintUI)


</code></pre><ol start="4">
<li>使用的例子：</li>
</ol>
<pre><code>&lt;mt-button type=&quot;primary&quot; size=&quot;large&quot;&gt;primary&lt;/mt-button&gt;


</code></pre><h2 id="使用-MUI-组件"><a href="#使用-MUI-组件" class="headerlink" title="使用 MUI 组件"></a>使用 MUI 组件</h2><p><a href="http://dev.dcloud.net.cn/mui/" target="_blank" rel="noopener">官网首页</a></p>
<p><a href="http://dev.dcloud.net.cn/mui/ui/" target="_blank" rel="noopener">文档地址</a></p>
<ol>
<li>导入 MUI 的样式表：</li>
</ol>
<pre><code>import &#39;../lib/mui/css/mui.min.css&#39;


</code></pre><ol start="2">
<li>在<code>webpack.config.js</code>中添加新的loader规则：</li>
</ol>
<pre><code>{ test: /\.(png|jpg|gif|ttf)$/, use: &#39;url-loader&#39; }


</code></pre><ol start="3">
<li>根据官方提供的文档和example，尝试使用相关的组件</li>
</ol>
<h2 id="将项目源码托管到oschina中"><a href="#将项目源码托管到oschina中" class="headerlink" title="将项目源码托管到oschina中"></a>将项目源码托管到oschina中</h2><ol>
<li>点击头像 -&gt; 修改资料 -&gt; SSH公钥 <a href="http://git.mydoc.io/?t=154712" target="_blank" rel="noopener">如何生成SSH公钥</a></li>
<li>创建自己的空仓储，使用 <code>git config --global user.name &quot;用户名&quot;</code> 和 <code>git config --global user.email ***@**.com</code> 来全局配置提交时用户的名称和邮箱</li>
<li>使用 <code>git init</code> 在本地初始化项目</li>
<li>使用 <code>touch README.md</code> 和 <code>touch .gitignore</code> 来创建项目的说明文件和忽略文件；</li>
<li>使用 <code>git add .</code> 将所有文件托管到 git 中</li>
<li>使用 <code>git commit -m &quot;init project&quot;</code> 将项目进行本地提交</li>
<li>使用 <code>git remote add origin 仓储地址</code>将本地项目和远程仓储连接，并使用origin最为远程仓储的别名</li>
<li>使用 <code>git push -u origin master</code> 将本地代码push到仓储中</li>
</ol>
<h2 id="App-vue-组件的基本设置"><a href="#App-vue-组件的基本设置" class="headerlink" title="App.vue 组件的基本设置"></a>App.vue 组件的基本设置</h2><ol>
<li>头部的固定导航栏使用 <code>Mint-UI</code> 的 <code>Header</code> 组件；</li>
<li>底部的页签使用 <code>mui</code> 的 <code>tabbar</code>;</li>
<li>购物车的图标，使用 <code>icons-extra</code> 中的 <code>mui-icon-extra mui-icon-extra-cart</code>，同时，应该把其依赖的字体图标文件 <code>mui-icons-extra.ttf</code>，复制到 <code>fonts</code> 目录下！</li>
<li>将底部的页签，改造成 <code>router-link</code> 来实现单页面的切换；</li>
<li>Tab Bar 路由激活时候设置高亮的两种方式：</li>
</ol>
<ul>
<li>全局设置样式如下：</li>
</ul>
<pre><code>     .router-link-active{

          color:#007aff !important;

    }


</code></pre><ul>
<li>或者在 <code>new VueRouter</code> 的时候，通过 <code>linkActiveClass</code> 来指定高亮的类：</li>
</ul>
<pre><code>     // 创建路由对象

    var router = new VueRouter({

      routes: [

        { path: &#39;/&#39;, redirect: &#39;/home&#39; }

      ],

      linkActiveClass: &#39;mui-active&#39;

    });


</code></pre><h2 id="实现-tabbar-页签不同组件页面的切换"><a href="#实现-tabbar-页签不同组件页面的切换" class="headerlink" title="实现 tabbar 页签不同组件页面的切换"></a>实现 tabbar 页签不同组件页面的切换</h2><ol>
<li>将 tabbar 改造成 <code>router-link</code> 形式，并指定每个连接的 <code>to</code> 属性；</li>
<li>在入口文件中导入需要展示的组件，并创建路由对象：</li>
</ol>
<pre><code>    // 导入需要展示的组件

    import Home from &#39;./components/home/home.vue&#39;

    import Member from &#39;./components/member/member.vue&#39;

    import Shopcar from &#39;./components/shopcar/shopcar.vue&#39;

    import Search from &#39;./components/search/search.vue&#39;



    // 创建路由对象

    var router = new VueRouter({

      routes: [

        { path: &#39;/&#39;, redirect: &#39;/home&#39; },

        { path: &#39;/home&#39;, component: Home },

        { path: &#39;/member&#39;, component: Member },

        { path: &#39;/shopcar&#39;, component: Shopcar },

        { path: &#39;/search&#39;, component: Search }

      ],

      linkActiveClass: &#39;mui-active&#39;

    });


</code></pre><h2 id="使用-mt-swipe-轮播图组件"><a href="#使用-mt-swipe-轮播图组件" class="headerlink" title="使用 mt-swipe 轮播图组件"></a>使用 mt-swipe 轮播图组件</h2><ol>
<li>假数据：</li>
</ol>
<pre><code>lunbo: [

        &#39;http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg&#39;,

        &#39;http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg&#39;,

        &#39;http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg&#39;

      ]


</code></pre><ol start="2">
<li>引入轮播图组件：</li>
</ol>
<pre><code>&lt;!-- Mint-UI 轮播图组件 --&gt;

    &lt;div class=&quot;home-swipe&quot;&gt;

      &lt;mt-swipe :auto=&quot;4000&quot;&gt;

        &lt;mt-swipe-item v-for=&quot;(item, i) in lunbo&quot; :key=&quot;i&quot;&gt;

          &lt;img :src=&quot;item&quot; alt=&quot;&quot;&gt;

        &lt;/mt-swipe-item&gt;

      &lt;/mt-swipe&gt;

    &lt;/div&gt;

  &lt;/div&gt;


</code></pre><h2 id="在-vue组件中使用vue-resource获取数据"><a href="#在-vue组件中使用vue-resource获取数据" class="headerlink" title="在.vue组件中使用vue-resource获取数据"></a>在<code>.vue</code>组件中使用<code>vue-resource</code>获取数据</h2><ol>
<li>运行<code>cnpm i vue-resource -S</code>安装模块</li>
<li>导入 vue-resource 组件</li>
</ol>
<pre><code>import VueResource from &#39;vue-resource&#39;

</code></pre><ol start="3">
<li>在vue中使用 vue-resource 组件</li>
</ol>
<pre><code>Vue.use(VueResource);

</code></pre><h1 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h1><h2 id="使用mui的tab-top-webview-main完成分类滑动栏"><a href="#使用mui的tab-top-webview-main完成分类滑动栏" class="headerlink" title="使用mui的tab-top-webview-main完成分类滑动栏"></a>使用mui的<code>tab-top-webview-main</code>完成分类滑动栏</h2><h3 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h3><ol>
<li>和 App.vue 中的 <code>router-link</code> 身上的类名 <code>mui-tab-item</code> 存在兼容性问题，导致tab栏失效，可以把<code>mui-tab-item</code>改名为<code>mui-tab-item1</code>，并复制相关的类样式，来解决这个问题；</li>
</ol>
<pre><code>    .mui-bar-tab .mui-tab-item1.mui-active {
      color: #007aff;
    }

    .mui-bar-tab .mui-tab-item1 {
      display: table-cell;
      overflow: hidden;
      width: 1%;
      height: 50px;
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
      text-overflow: ellipsis;
      color: #929292;
    }

    .mui-bar-tab .mui-tab-item1 .mui-icon {
      top: 3px;
      width: 24px;
      height: 24px;
      padding-top: 0;
      padding-bottom: 0;
    }

    .mui-bar-tab .mui-tab-item1 .mui-icon~.mui-tab-label {
      font-size: 11px;
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
    }
</code></pre><ol start="2">
<li><code>tab-top-webview-main</code>组件第一次显示到页面中的时候，无法被滑动的解决方案：</li>
</ol>
<ul>
<li>先导入 mui 的JS文件:</li>
</ul>
<pre><code> import mui from &#39;../../../lib/mui/js/mui.min.js&#39;
</code></pre><ul>
<li>在 组件的 <code>mounted</code> 事件钩子中，注册 mui 的滚动事件：</li>
</ul>
<pre><code>     mounted() {
        // 需要在组件的 mounted 事件钩子中，注册 mui 的 scroll 滚动事件
        mui(&#39;.mui-scroll-wrapper&#39;).scroll({
          deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006
        });
      }
</code></pre><ol start="3">
<li>滑动的时候报警告：<code>Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080</code></li>
</ol>
<pre><code>解决方法，可以加上* { touch-action: none; } 这句样式去掉。
</code></pre><p>原因：（是chrome为了提高页面的滑动流畅度而新折腾出来的一个东西） <a href="http://www.cnblogs.com/pearl07/p/6589114.html" target="_blank" rel="noopener">http://www.cnblogs.com/pearl07/p/6589114.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action</a></p>
<h2 id="移除严格模式"><a href="#移除严格模式" class="headerlink" title="移除严格模式"></a>移除严格模式</h2><p><a href="https://github.com/genify/babel-plugin-transform-remove-strict-mode" target="_blank" rel="noopener">babel-plugin-transform-remove-strict-mode</a></p>
<h2 id="vue-preview"><a href="#vue-preview" class="headerlink" title="vue-preview"></a><a href="https://github.com/LS1231/vue-preview" target="_blank" rel="noopener">vue-preview</a></h2><p>一个Vue集成PhotoSwipe图片预览插件</p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">钟志豪</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://yoursite.com/2020/07/20/vue/">http://yoursite.com/2020/07/20/vue/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">钟志豪</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                    <span class="chip bg-color">前端</span>
                                </a>
                            
                                <a href="/tags/vue/">
                                    <span class="chip bg-color">vue</span>
                                </a>
                            
                                <a href="/tags/%E6%A1%86%E6%9E%B6/">
                                    <span class="chip bg-color">框架</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: null,
        id: '2020-07-20T13-43-53',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/07/20/git/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="git的用法">
                        
                        <span class="card-title">git的用法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            git的基础用法
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-07-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            钟志豪
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/git/">
                        <span class="chip bg-color">git</span>
                    </a>
                    
                    <a href="/tags/%E5%B7%A5%E5%85%B7/">
                        <span class="chip bg-color">工具</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/07/20/javascript-gao-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="javascript高级">
                        
                        <span class="card-title">javascript高级</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            javascript高级
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            钟志豪
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/javascript/">
                        <span class="chip bg-color">javascript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




                <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

            
                <div class="container row center-align" style="margin-bottom: 15px !important;">
                    <div class="col s12 m8 l8 copy-right">
                        Copyright&nbsp;&copy;
                        <span id="year">2020</span>
                        <a href="/about" target="_blank">
                            zzhのblog
                        </a>
                        |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;
                        <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
                        <br>
                        
                            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">93.8k</span>&nbsp;字
                            
                                
                                    
                                        
                                            
                                                
                                                    <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
                                                    </span>
                                                    
                                                        
                                                            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
                                                            </span>
                                                            
                                                                <br>
                                                                
                                                                    <span id="sitetime">载入运行时间...</span>
                                                                    <script>
                                                                        function siteTime() {
                                                                            var seconds = 1000;
                                                                            var minutes = seconds * 60;
                                                                            var hours = minutes * 60;
                                                                            var days = hours * 24;
                                                                            var years = days * 365;
                                                                            var today = new Date();
                                                                            var startYear = "2020";
                                                                            var startMonth = "7";
                                                                            var startDate = "16";
                                                                            var startHour = "0";
                                                                            var startMinute = "0";
                                                                            var startSecond = "0";
                                                                            var todayYear = today.getFullYear();
                                                                            var todayMonth = today.getMonth() + 1;
                                                                            var todayDate = today.getDate();
                                                                            var todayHour = today.getHours();
                                                                            var todayMinute = today.getMinutes();
                                                                            var todaySecond = today.getSeconds();
                                                                            var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                                                                            var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                                                                            var diff = t2 - t1;
                                                                            var diffYears = Math.floor(diff / years);
                                                                            var diffDays = Math.floor((diff / days) - diffYears * 365);
                                                                            var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                                                                            var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                                                                                minutes);
                                                                            var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                                                                                diffMinutes * minutes) / seconds);
                                                                            if (startYear == todayYear) {
                                                                                document.getElementById("year").innerHTML = todayYear;
                                                                                document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                                                                                    " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                                                                            } else {
                                                                                document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                                                                                document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                                                                                    " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                                                                            }
                                                                        }
                                                                        setInterval(siteTime, 1000);
                                                                    </script>
                                                                    
                                                                        <br>
                                                                        
                    </div>
                    <div class="col s12 m4 l4 social-link social-statis">
                        
    <a href="https://github.com/zhongzhihao123" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>
    

        
            <a href="mailto:514974922@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
                <i class="fas fa-envelope-open"></i>
            </a>
            

                

                        

                                
                                    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=514974922" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 514974922" data-position="top" data-delay="50">
                                        <i class="fab fa-qq"></i>
                                    </a>
                                    

                                        

                                                
                                                        
                                                            <a href="1564648979" class="tooltipped" target="_blank" data-tooltip="关注我的微信：1564648979" data-position="top" data-delay="50">
                                                                <i class="fab fa-weixin"></i>
                                                            </a>
                                                            
                                                                
                                                                    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
                                                                        <i class="fas fa-rss"></i>
                                                                    </a>
                                                                    
                    </div>

                </div>
</footer>

<!-- 插入聊天 -->
<!-- <script type="text/javascript">
    window.$crisp = [];
    window.CRISP_WEBSITE_ID = "2d9269d7-ff9f-4f99-bcb4-0bfa8adb939c";
    (function() {
        d = document;
        s = d.createElement("script");
        s.src = "https://client.crisp.chat/l.js";
        s.async = 1;
        d.getElementsByTagName("head")[0].appendChild(s);
    })();
</script> -->

<div class="progress-bar"></div>

                    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

                        <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                            <script src="/libs/materialize/materialize.min.js"></script>
                            <script src="/libs/masonry/masonry.pkgd.min.js"></script>
                            <script src="/libs/aos/aos.js"></script>
                            <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
                            <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                            <script src="/js/matery.js"></script>



                            <!-- Baidu Analytics -->

                                <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                    
                                        <script src="/libs/others/clicklove.js" async="async"></script>
                                        
                                            
                                                <script async src="/libs/others/busuanzi.pure.mini.js"></script>
                                                

                                                    

                                                            

                                                                    

                                                                            

                                                                                        

                                                                                                
                                                                                                    <script src="/libs/instantpage/instantpage.js" type="module"></script>
                                                                                                    

    <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
    <script type="text/javascript">
        var OriginTitile = document.title,
            st;
        document.addEventListener("visibilitychange", function() {
            document.hidden ? (document.title = "看不见我🙈~看不见我🙈~", clearTimeout(st)) : (document.title = "(๑•̀ㅂ•́) ✧被发现了～", st = setTimeout(function() {
                document.title = OriginTitile
            }, 3e3))
        })
    </script>

    <!-- weather -->
    <script type="text/javascript">
        WIDGET = {
            FID: 'pDqd7dnmqi'
        }
    </script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>

    <!-- 背景动态彩图 -->
    <script src="/js/backgroundcaitu.js"></script>
    <!-- 鼠标特效 -->
    <script src="/js/shubiaotexiao.js"></script>
    <!-- 雪花特效 -->
    <!-- <script src="/js/snow.js"></script> -->
    <!-- 樱花特效 -->
    <script src="/js/yinhua.js"></script>

</html>